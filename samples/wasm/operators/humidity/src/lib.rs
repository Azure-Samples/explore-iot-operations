// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

// Generated by `wit_bindgen::generate` expansion.
#![allow(clippy::missing_safety_doc)]

use core::panic;

use tinykube_wasm_sdk::logger::{self, Level};
use tinykube_wasm_sdk::macros::accumulate_operator;
use tinykube_wasm_sdk::metrics::{self, CounterValue, Label};

#[accumulate_operator]
fn accumulate_humidity(staged: DataModel, inputs: Vec<DataModel>) -> DataModel {
    let labels = vec![Label {
        key: "module".to_owned(),
        value: "module-humidity/accumulate".to_owned(),
    }];
    let _ = metrics::add_to_counter("requests", CounterValue::U64(1), Some(&labels));

    let DataModel::Message(mut result) = staged else {
        panic!("Unexpected input type");
    };

    // Extract payload from message to process
    let staged_payload = match &result.payload {
        BufferOrBytes::Buffer(buffer) => buffer.read(),
        BufferOrBytes::Bytes(bytes) => bytes.clone(),
    };

    let (mut count, mut avg, mut max, mut min, mut last) = if staged_payload.is_empty() {
        (0, 0.0, f64::MIN, f64::MAX, 0.0)
    } else {
        match serde_json::from_slice(&staged_payload).unwrap() {
            Measurement::Humidity(measurement) => {
                // average * count = sum; avg works as the sum before divided by count.
                let count = measurement.count;
                let sum = measurement.average * count as f64;
                (
                    count,
                    sum,
                    measurement.max,
                    measurement.min,
                    measurement.last,
                )
            }
            _ => (0, 0.0, f64::MIN, f64::MAX, 0.0),
        }
    };

    let mut last_secs = 0;
    let mut last_nanos = 0;
    let mut result_topic = BufferOrBytes::Bytes(Vec::new());

    for input in inputs {
        let (ts, topic, payload) = match input {
            DataModel::Message(temp) => {
                // Extract payload from message to process
                (temp.timestamp.timestamp, temp.topic, match &temp.payload {
                    BufferOrBytes::Buffer(buffer) => buffer.read(),
                    BufferOrBytes::Bytes(bytes) => bytes.clone(),
                })
            }
            _ => panic!("Unexpected input type"),
        };

        let measurement: Measurement = serde_json::from_slice(&payload).unwrap();
        match measurement {
            Measurement::Humidity(measurement) => {
                let value = measurement.value.unwrap();
                // Add each humidity into average
                avg += value;
                count += 1;

                // Compare and return max and min values
                if value > max {
                    max = value;
                }
                if value < min {
                    min = value;
                }

                // Compare the obtain the latest value
                if ts.secs >= last_secs || (ts.secs == last_secs && ts.nanos >= last_nanos) {
                    last = value;
                    last_secs = ts.secs;
                    last_nanos = ts.nanos;
                }

                // Set the topic
                result_topic = topic;
            }
            _ => panic!("Unexpected measurement type."),
        }
    }

    // Compute average humidity
    avg /= count as f64;

    // Create the payload
    let payload_str = format!(
        r#"{{"humidity":{{"count":{count},"max":{max},"min":{min},"average":{avg},"last":{last}}}}}"#,
    );

    logger::log(
        Level::Info,
        "module-humidity/accumulate",
        &payload_str,
    );

    let payload = payload_str.as_bytes().to_vec();
    result.payload = BufferOrBytes::Bytes(payload);
    result.timestamp.timestamp.secs = last_secs;
    result.timestamp.timestamp.nanos = last_nanos;
    result.topic = result_topic;
    DataModel::Message(result)
}


#[derive(Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub enum Measurement {
    #[serde(rename = "temperature")]
    Temperature(MeasurementTemperature),

    #[serde(rename = "humidity")]
    Humidity(MeasurementHumidity),

    #[serde(rename = "object")]
    Object(MeasurementObject),

    #[serde(rename = "sensor_data")]
    SensorData(MeasurementSensorData),
}

#[derive(Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct MeasurementTemperature {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<f64>,
    #[serde(default)]
    pub count: u64,
    #[serde(default)]
    pub max: f64,
    #[serde(default)]
    pub min: f64,
    #[serde(default)]
    pub average: f64,
    #[serde(default)]
    pub last: f64,
    pub unit: MeasurementTemperatureUnit,
    #[serde(default)]
    pub overtemp: bool,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, serde::Deserialize, serde::Serialize)]
pub enum MeasurementTemperatureUnit {
    #[serde(rename = "C")]
    Celsius,

    #[serde(rename = "F")]
    Fahrenheit,
}

#[derive(Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct MeasurementHumidity {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<f64>,
    #[serde(default)]
    pub count: u64,
    #[serde(default)]
    pub max: f64,
    #[serde(default)]
    pub min: f64,
    #[serde(default)]
    pub average: f64,
    #[serde(default)]
    pub last: f64,
}

#[derive(Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct MeasurementObject {
    pub result: String,
}

#[derive(Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct MeasurementSensorData {
    #[serde(default)]
    pub temperature: Vec<MeasurementTemperature>,

    #[serde(default)]
    pub humidity: Vec<MeasurementHumidity>,

    #[serde(default)]
    pub object: Vec<MeasurementObject>,
}

impl Default for MeasurementSensorData {
    fn default() -> Self {
        Self::new()
    }
}

impl MeasurementSensorData {
    pub fn new() -> Self {
        Self {
            temperature: Vec::new(),
            humidity: Vec::new(),
            object: Vec::new(),
        }
    }

    pub fn temperature(&mut self) -> &mut [MeasurementTemperature] {
        &mut self.temperature
    }

    pub fn humidity(&mut self) -> &mut [MeasurementHumidity] {
        &mut self.humidity
    }

    pub fn object(&mut self) -> &mut [MeasurementObject] {
        &mut self.object
    }
}
