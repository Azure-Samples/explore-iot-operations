// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

// Generated by `wit_bindgen::generate` expansion.
#![allow(clippy::missing_safety_doc)]

mod map_format {

    use wasm_graph_sdk::logger::{self, Level};
    use wasm_graph_sdk::macros::map_operator;
    use wasm_graph_sdk::metrics::{self, CounterValue, Label};

    // Set 224*224 and rgb24 since object detection models expect this size.
    const WIDTH: u32 = 224;
    const HEIGHT: u32 = 224;
    const FORMAT: &str = "rgb24";
    const CELL_LENGTH: u32 = 3; // RGB has 3 channels

    fn decode_and_rescale_init(configuration: ModuleConfiguration) -> bool {
        logger::log(
            Level::Info,
            "module-format/map",
            &format!("Initialization function invoked"),
        );

        for (key, value) in configuration.properties.iter() {
            logger::log(
                Level::Info,
                "module-format/map",
                &format!("Initialization received the property (key='{key}', value='{value}')."),
            );
        }

        true
    }

    #[map_operator(init = "decode_and_rescale_init")]
    fn decode_and_rescale(input: DataModel) -> Result<DataModel, Error> {
        let labels = vec![Label {
            key: "module".to_owned(),
            value: "module-format/map".to_owned(),
        }];
        let _ = metrics::add_to_counter("requests", CounterValue::U64(1), Some(&labels));

        let (payload, timestamp) = match input {
            DataModel::Message(message) => {
                (message.payload.read(), message.timestamp)
            },
            DataModel::Snapshot(snapshot) => {
                let format = match snapshot.format {
                    BufferOrString::Buffer(ref s) => String::from_utf8_lossy(&s.read()).to_string(),
                    BufferOrString::String(ref s) => s.clone(),
                };
                if format == FORMAT && snapshot.width == WIDTH && snapshot.height == HEIGHT {
                    // If the snapshot is already in the desired format and size, return it directly
                    return Ok(DataModel::Snapshot(snapshot));
                }
                (snapshot.frame.read(), snapshot.timestamp)
            },
            DataModel::BufferOrBytes(_) => return Err(Error {message: "Unexpected input type.".to_string()}),
        };

        // Extract payload from message to process
        let payload = &payload;

        // Start to decode and rescale the image.
        let img = match image::load_from_memory(&payload) {
            Ok(img) => img,
            Err(_) => {
                // Check payload size to ensure it matches the expected size.
                if payload.len() != (WIDTH * HEIGHT * CELL_LENGTH) as usize {
                    logger::log(
                        Level::Info,
                        "module-format/map",
                        &format!("Unexpected image format or size: expected {} bytes, got {} bytes",
                                 WIDTH * HEIGHT * CELL_LENGTH,
                                 payload.len()),
                    );
                    return Err(Error {message: "Unexpected image format or size.".to_string()});
                }
                // If the image format cannot be guessed but the payload size is correct, it
                // is possibly already in the desired format. So we will return it directly.
                let result = Snapshot {
                    timestamp: timestamp,
                    format: BufferOrString::String(FORMAT.to_string()),
                    width: WIDTH,
                    height: HEIGHT,
                    frame: BufferOrBytes::Bytes(payload.to_vec()),
                };
                return Ok(DataModel::Snapshot(result));
            }
        };

        let rgb_img = img.to_rgb8();
        let resized_img = image::imageops::resize(
            &rgb_img,
            WIDTH,
            HEIGHT,
            image::imageops::FilterType::Lanczos3,
        );

        let result = Snapshot {
            timestamp: timestamp,
            format: BufferOrString::String(FORMAT.to_string()),
            width: WIDTH,
            height: HEIGHT,
            frame: BufferOrBytes::Bytes(resized_img.to_vec()),
        };

        Ok(DataModel::Snapshot(result))
    }
}