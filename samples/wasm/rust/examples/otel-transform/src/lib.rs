// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

// Generated by `wit_bindgen::generate` expansion.
#![allow(clippy::missing_safety_doc)]

mod otel_transform {
    use std::sync::OnceLock;

    use serde_json::Value;
    use tinykube_wasm_sdk::logger::{self, Level};
    use tinykube_wasm_sdk::macros::map_operator;

    static METRIC_NAME: OnceLock<String> = OnceLock::new();
    static METRIC_NAME_PATH: OnceLock<String> = OnceLock::new();
    static METRIC_VALUE: OnceLock<String> = OnceLock::new();
    static METRIC_TYPE: OnceLock<String> = OnceLock::new();
    static METRIC_TIMESTAMP: OnceLock<String> = OnceLock::new();

    #[derive(Clone, Debug, serde::Deserialize, serde::Serialize, PartialEq)]
    pub struct KeyValuePair {
        pub key: String,
        pub value: String,
    }

    #[derive(Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct OtelPayload {
        pub metrics: Vec<OtelMetric>,
    }

    #[derive(Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct OtelMetric {
        pub name: String,
        pub value: f64,
        pub metric_type: String,
        pub timestamp: Option<i64>,
        pub attributes: Option<Vec<KeyValuePair>>,
    }

    fn value_to_otel_init(configuration: ModuleConfiguration) -> bool {
        logger::log(
            Level::Info,
            "module-otel-transform/map",
            "Initialization function invoked",
        );

        for (key, value) in configuration.properties {
            logger::log(
                Level::Info,
                "module-otel-transform/map",
                &format!("Initialization received the property (key='{key}', value='{value}')."),
            );

            match key.as_str() {
                "metricName" => {
                    METRIC_NAME.set(value.clone()).unwrap();
                    logger::log(
                        Level::Info,
                        "module-otel-transform/map",
                        &format!("Configured metric name: {value}"),
                    );
                }
                "metricNamePath" => {
                    METRIC_NAME_PATH.set(value.clone()).unwrap();
                    logger::log(
                        Level::Info,
                        "module-otel-transform/map",
                        &format!("Configured metric name path: {value}"),
                    );
                }
                "metricValuePath" => {
                    METRIC_VALUE.set(value.clone()).unwrap();
                    logger::log(
                        Level::Info,
                        "module-otel-transform/map",
                        &format!("Configured metric value: {value}"),
                    );
                }
                "metricType" => {
                    METRIC_TYPE.set(value.clone()).unwrap();
                    logger::log(
                        Level::Info,
                        "module-otel-transform/map",
                        &format!("Configured metric type: {value}"),
                    );
                }
                "metricTimestampPath" => {
                    METRIC_TIMESTAMP.set(value.clone()).unwrap();
                    logger::log(
                        Level::Info,
                        "module-otel-transform/map",
                        &format!("Configured metric timestamp: {value}"),
                    );
                }
                _ => {
                    logger::log(
                        Level::Warn,
                        "module-otel-transform/map",
                        &format!("Unknown property key: {key}"),
                    );
                }
            }
        }

        true
    }

    // Helper function to get nested values using dot notation
    fn get_by_path<'a>(value: &'a Value, path: &str) -> Option<&'a Value> {
        let keys: Vec<&str> = path.split('.').collect();
        let mut current = value;

        for key in keys {
            current = current.get(key)?;
        }

        Some(current)
    }

    #[map_operator(init = "value_to_otel_init")]
    fn value_to_otel(input: DataModel) -> Result<DataModel, ModuleError> {
        // Default result is unmodified input
        let DataModel::Message(mut result) = input else {
            return Err(ModuleError {
                message: "Unexpected input type".to_string(),
            });
        };

        // Attributes are user properties prefixed with "otel/"
        let attributes: Vec<KeyValuePair> = result
            .properties
            .user_properties
            .iter()
            .filter_map(|(key, value)| {
                let key = match key {
                    BufferOrString::String(s) => s.to_string(),
                    BufferOrString::Buffer(b) => String::from_utf8_lossy(&b.read()).to_string(),
                };
                let value = match value {
                    BufferOrString::String(s) => s.to_string(),
                    BufferOrString::Buffer(b) => String::from_utf8_lossy(&b.read()).to_string(),
                };
                let ret = if key.starts_with("otel/") {
                    Some(KeyValuePair {
                        key: key.trim_start_matches("otel/").to_string(),
                        value: value.to_string(),
                    })
                } else {
                    None
                };

                ret
            })
            .collect();

        let attributes = if attributes.is_empty() {
            None
        } else {
            Some(attributes)
        };

        let staged_payload = &result.payload.read();

        // Parse generic payload from JSON
        let parsed_payload = match serde_json::from_slice::<serde_json::Value>(staged_payload) {
            Ok(payload) => payload,
            Err(e) => {
                logger::log(
                    Level::Error,
                    "module-otel-transform/map",
                    &format!("Failed to parse JSON payload: {e}"),
                );
                return Ok(DataModel::Message(result)); // Return the unmodified input on error
            }
        };

        let hardcoded_metric_name = METRIC_NAME.get();
        let find_metric_name_path = METRIC_NAME_PATH.get();

        let find_metric_value = METRIC_VALUE.get().unwrap();
        let metric_type = METRIC_TYPE
            .get()
            .unwrap_or(&String::from("type-placeholder"))
            .to_string();

        let metric_name = if let Some(path) = find_metric_name_path {
            get_by_path(&parsed_payload, path)
                .and_then(|v| v.as_str())
                .unwrap_or("wasm-placeholder")
                .to_string()
        } else {
            hardcoded_metric_name.unwrap().to_string()
        };

        let metric_value = get_by_path(&parsed_payload, find_metric_value)
            .and_then(serde_json::Value::as_f64)
            .unwrap_or(0.0) as f64;

        let timestamp = if let Some(find_metric_timestamp) = METRIC_TIMESTAMP.get() {
            get_by_path(&parsed_payload, &find_metric_timestamp.to_string())
                .and_then(|v| v.as_str())
                .map(|metric_timestamp| {
                    chrono::DateTime::parse_from_rfc3339(metric_timestamp).map_or_else(
                        |_| {
                            logger::log(
                                Level::Error,
                                "module-otel-transform/map",
                                &format!("Failed to parse ISO 8601 timestamp: {metric_timestamp}"),
                            );
                            0
                        },
                        |dt| {
                            dt.timestamp_nanos_opt().unwrap_or_else(|| {
                                logger::log(
                                    Level::Error,
                                    "module-otel-transform/map",
                                    "Failed to convert timestamp to nanoseconds",
                                );
                                0
                            })
                        },
                    )
                })
        } else {
            chrono::Utc::now().timestamp_nanos_opt()
        };

        let new_payload = OtelMetric {
            name: metric_name,
            value: metric_value,
            metric_type,
            timestamp,
            attributes,
        };

        let otel_payload = OtelPayload {
            metrics: vec![new_payload],
        };

        result.payload = BufferOrBytes::Bytes(serde_json::to_vec(&otel_payload).unwrap());

        Ok(DataModel::Message(result))
    }
}
