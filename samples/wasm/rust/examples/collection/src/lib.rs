// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

// Generated by `wit_bindgen::generate` expansion.
#![allow(clippy::missing_safety_doc)]

use wasm_graph_sdk::logger::{self, Level};
use wasm_graph_sdk::macros::accumulate_operator;
use wasm_graph_sdk::metrics::{self, CounterValue, Label};

#[accumulate_operator]
fn accumulate_sensor_data(
    staged: DataModel,
    inputs: Vec<DataModel>,
) -> Result<DataModel, Error> {
    let labels = vec![Label {
        key: "module".to_owned(),
        value: "module-collection/accumulate".to_owned(),
    }];
    let _ = metrics::add_to_counter("requests", CounterValue::U64(1), Some(&labels));

    logger::log(
        Level::Info,
        "module-collection/accumulate",
        &format!("enter accumulate with {} inputs", inputs.len()),
    );

    let DataModel::Message(mut result) = staged else {
        return Err(Error {message: "Unexpected input type.".to_string()});
    };

    // Extract payload from message to process
    let staged_payload = result.payload.read();

    // Initialize sensor data
    let mut sensor_data = if staged_payload.is_empty() {
        logger::log(Level::Info, "module-collection/accumulate", "first initialization");
        Measurement::SensorData(MeasurementSensorData::new())
    } else {
        logger::log(Level::Info, "module-collection/accumulate", "adding ...");
        match serde_json::from_slice(&staged_payload).unwrap() {
            Measurement::SensorData(sensor_data) => Measurement::SensorData(sensor_data),
            _ => {
                return Err(Error {message: "Unexpected type for result.".to_string()});
            }
        }
    };

    for input in inputs {
        let payload = match input {
            DataModel::Message(temp) => {
                // Extract payload from message to process
                temp.payload.read()
            }
            DataModel::Snapshot(rtsp) => {
                // Extract payload from message to process
                rtsp.frame.read()
            }
            DataModel::BufferOrBytes(_) => {
                return Err(Error {message: "Unexpected input type.".to_string()});
            }
        };

        let measurement: Measurement = serde_json::from_slice(&payload).unwrap();
        sensor_data = match measurement {
            Measurement::Temperature(measurement) => {
                // Push temperature measurement to result.
                match sensor_data {
                    Measurement::SensorData(mut sensor_data) => {
                        logger::log(Level::Info, "module-collection/accumulate", "+ temperature");
                        sensor_data.temperature.push(measurement);
                        Measurement::SensorData(sensor_data)
                    }
                    _ => return Err(Error {message: "Unexpected type for result.".to_string()}),
                }
            }
            Measurement::Humidity(measurement) => {
                // Push humidity measurement to result.
                match sensor_data {
                    Measurement::SensorData(mut sensor_data) => {
                        logger::log(Level::Info, "module-collection/accumulate", "+ humidity");
                        sensor_data.humidity.push(measurement);
                        Measurement::SensorData(sensor_data)
                    }
                    _ => return Err(Error {message: "Unexpected type for result.".to_string()}),
                }
            }
            Measurement::Object(measurement) => {
                // Push rtsp measurement to result.
                match sensor_data {
                    Measurement::SensorData(mut sensor_data) => {
                        logger::log(Level::Info, "module-collection/accumulate", "+ object");
                        sensor_data.object.push(measurement);
                        Measurement::SensorData(sensor_data)
                    }
                    _ => return Err(Error {message: "Unexpected type for result.".to_string()}),
                }
            }
            Measurement::SensorData(_) => return Err(Error {message: "Unexpected measurement type.".to_string()}),
        }
    }

    let payload = serde_json::to_vec(&sensor_data).unwrap();
    result.payload = BufferOrBytes::Bytes(payload);
    Ok(DataModel::Message(result))
}

#[derive(Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub enum Measurement {
    #[serde(rename = "temperature")]
    Temperature(MeasurementTemperature),

    #[serde(rename = "humidity")]
    Humidity(MeasurementHumidity),

    #[serde(rename = "object")]
    Object(MeasurementObject),

    #[serde(rename = "sensor_data")]
    SensorData(MeasurementSensorData),
}

#[derive(Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct MeasurementTemperature {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<f64>,
    #[serde(default)]
    pub count: u64,
    #[serde(default)]
    pub max: f64,
    #[serde(default)]
    pub min: f64,
    #[serde(default)]
    pub average: f64,
    #[serde(default)]
    pub last: f64,
    pub unit: MeasurementTemperatureUnit,
    #[serde(default)]
    pub overtemp: bool,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, serde::Deserialize, serde::Serialize)]
pub enum MeasurementTemperatureUnit {
    #[serde(rename = "C")]
    Celsius,

    #[serde(rename = "F")]
    Fahrenheit,
}

#[derive(Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct MeasurementHumidity {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<f64>,
    #[serde(default)]
    pub count: u64,
    #[serde(default)]
    pub max: f64,
    #[serde(default)]
    pub min: f64,
    #[serde(default)]
    pub average: f64,
    #[serde(default)]
    pub last: f64,
}

#[derive(Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct MeasurementObject {
    pub result: String,
}

#[derive(Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct MeasurementSensorData {
    #[serde(default)]
    pub temperature: Vec<MeasurementTemperature>,

    #[serde(default)]
    pub humidity: Vec<MeasurementHumidity>,

    #[serde(default)]
    pub object: Vec<MeasurementObject>,
}

impl Default for MeasurementSensorData {
    fn default() -> Self {
        Self::new()
    }
}

impl MeasurementSensorData {
    pub fn new() -> Self {
        Self {
            temperature: Vec::new(),
            humidity: Vec::new(),
            object: Vec::new(),
        }
    }

    pub fn temperature(&mut self) -> &mut [MeasurementTemperature] {
        &mut self.temperature
    }

    pub fn humidity(&mut self) -> &mut [MeasurementHumidity] {
        &mut self.humidity
    }

    pub fn object(&mut self) -> &mut [MeasurementObject] {
        &mut self.object
    }
}
