// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

// Generated by `wit_bindgen::generate` expansion.
#![allow(clippy::missing_safety_doc)]

use wasm_graph_sdk::logger::{self, Level};
use wasm_graph_sdk::macros::delay_operator;
use wasm_graph_sdk::metrics::{self, CounterValue, Label};

const WINDOW_MS: u128 = 10000; // 10 seconds

fn delay_init(configuration: ModuleConfiguration) -> bool {
    logger::log(
        Level::Info,
        "module-window/delay",
        &format!("Initialization function invoked"),
    );

    for (key, value) in configuration.properties {
        logger::log(
            Level::Info,
            "module-window/delay",
            &format!("Initialization received the property (key='{key}', value='{value}')."),
        );
    }

    true
}

#[delay_operator(init = "delay_init")]
fn delay(input: DataModel, timestamp: HybridLogicalClock) -> HybridLogicalClock {
    let labels = vec![Label {
        key: "module".to_owned(),
        value: "module-window/delay".to_owned(),
    }];

    let _ = metrics::add_to_counter("requests", CounterValue::U64(1), Some(&labels));

    let mut time = match input {
        DataModel::Message(message) => message.timestamp.timestamp,
        DataModel::Snapshot(frame) => frame.timestamp.timestamp,
        DataModel::BufferOrBytes(_) => timestamp.timestamp,
    };

    // Make ts delay to next multiple of `WINDOWS_MS` milliseconds
    let time_duration = Duration::from(time);
    let time_ms = time_duration.as_millis();
    if time_ms % WINDOW_MS != 0 {
        let remainder = WINDOW_MS - (time_ms % WINDOW_MS);
        time = (time_duration + Duration::from_millis(u64::try_from(remainder).unwrap())).into();
        time.nanos = time.nanos - (time.nanos % 1_000_000); // round to milliseconds
    };
    let mut timestamp = timestamp;
    timestamp.timestamp = time;
    timestamp.counter = 0;

    logger::log(
        Level::Info,
        "module-window/delay",
        &format!("delayed to {timestamp:?}"),
    );

    timestamp
}
