// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

// Generated by `wit_bindgen::generate` expansion.
#![allow(clippy::missing_safety_doc)]

use serde::{Deserialize, Serialize};
use tinykube_wasm_sdk::logger::{self, Level};
use tinykube_wasm_sdk::macros::map_operator;

/// Minimal view of the input: we only deserialize what we need.
#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
struct Input {
    id: usize,
    height: u32,
    width: u32,
    #[serde(default)]
    detections: Vec<Detection>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
struct Detection {
    #[serde(rename = "Id")]
    id: String,
    insight_name: String,
    model_type: String,
    instances: Vec<Instance>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
struct Instance {
    x: f32,
    y: f32,
    width: f32,
    height: f32,
    start: f64,
    end: f64,
    start_time: String,
    end_time: String,
    confidence: f32,
}

/// The flattened row you can store in your DB.
#[derive(Debug, Serialize)]
#[serde(rename_all = "snake_case")]
struct DetectionRow {
    // Root (frame) context
    id: usize,
    frame_width: u32,
    frame_height: u32,

    // Parent detection metadata
    detection_id: String,
    insight_name: String,
    model_type: String,

    // Instance fields
    x: f32,
    y: f32,
    width: f32,
    height: f32,
    start: f64,
    end: f64,
    start_time: String,
    end_time: String,
    confidence: f32,
}

fn map_init(_configuration: ModuleConfiguration) -> bool {
    // Add code here to process the module init properties and module schemas from the configuration

    true
}

#[map_operator(init = "map_init")]
fn map(input: DataModel) -> DataModel {
    logger::log(Level::Info, "viconverter/map", "Get a map request");
    // create result object from input
    let DataModel::Message(mut result) = input else {
        panic!("Unexpected input type");
    };

    // Extract payload from message to process
    let staged_payload = match &result.payload {
        BufferOrBytes::Buffer(buffer) => buffer.read(),
        BufferOrBytes::Bytes(bytes) => bytes.clone(),
    };

    let payload_str = std::str::from_utf8(&staged_payload).unwrap();
    let Input {
        id,
        height,
        width,
        detections,
    } = serde_json::from_str(payload_str).unwrap();

    let total_instances = detections.iter().map(|d| d.instances.len()).sum();
    let mut rows = Vec::with_capacity(total_instances);

    for det in detections {
        for inst in det.instances {
            rows.push(DetectionRow {
                id,
                frame_width: width,
                frame_height: height,

                detection_id: det.id.clone(),
                insight_name: det.insight_name.clone(),
                model_type: det.model_type.clone(),

                x: inst.x,
                y: inst.y,
                width: inst.width,
                height: inst.height,
                start: inst.start,
                end: inst.end,
                start_time: inst.start_time,
                end_time: inst.end_time,
                confidence: inst.confidence,
            });
        }
    }

    let serialized_rows = serde_json::to_vec(&rows).unwrap();
    result.payload = BufferOrBytes::Bytes(serialized_rows);
    // return result
    DataModel::Message(result)
}
