// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

// Generated by `wit_bindgen::generate` expansion.
#![allow(clippy::missing_safety_doc)]

use tinykube_wasm_sdk::logger::{self, Level};
use tinykube_wasm_sdk::macros::map_operator;
use tinykube_wasm_sdk::metrics::{self, CounterValue, Label};
use tinykube_wasm_sdk::state_store::{self, HybridLogicalClock as StateStoreHybridLogicalClock};
use tinykube_wasm_sdk::state_store::{SetConditions, SetOptions};

#[map_operator]
fn overtemp_check(input: DataModel) -> DataModel {
    // Record temperatures higher than 100 C as over-temperature alert.
    // Propagate this alert in all future reports even if the temperature drops again.
    const OVERTEMP_KEY: &str = "overtemp";
    const WET_FLAG: &str = "wet_flag";

    let labels = vec![Label {
        key: "module".to_owned(),
        value: "module-enrichment/map".to_owned(),
    }];
    let _ = metrics::add_to_counter("requests", CounterValue::U64(1), Some(&labels));

    // Extract message from input
    let DataModel::Message(message) = input else {
        panic!("Unexpected input type");
    };

    // Extract payload from message to process
    let payload = match &message.payload {
        BufferOrBytes::Buffer(buffer) => {
            let temp = buffer.read();
            temp
        }
        BufferOrBytes::Bytes(bytes) => bytes.clone(),
    };

    // Default result is modified input
    let mut result = Message {
        timestamp: message.timestamp,
        topic: BufferOrBytes::Bytes(b"sensors"[..].to_owned()),
        payload: message.payload,
        properties: message.properties,
        schema: None,
        content_type: None,
    };

    let payload_json = serde_json::from_slice(&payload).unwrap();
    logger::log(
        Level::Info,
        "module-enrichment/map",
        &format!("incoming payload {payload_json:?}"),
    );
    let sensor_data = match payload_json {
        Measurement::SensorData(sensor_data) => Measurement::SensorData(sensor_data),
        _ => {
            panic!("Unexpected type for result.");
        }
    };

    let sensor_data = match sensor_data {
        Measurement::SensorData(mut sensor_data) => {
            for temperature in sensor_data.temperature() {
                let MeasurementTemperature {
                    value,
                    count: _,
                    max,
                    min,
                    average: _,
                    last: _,
                    unit: _,
                    overtemp,
                } = temperature;

                if *max > 100.0 {
                    *overtemp = true;

                    match state_store::set(OVERTEMP_KEY.as_bytes(), b"true", None, None, SetOptions::default()) {
                        Ok(_) => logger::log(
                            Level::Warn,
                            "module-enrichment/map",
                            &format!("over-temperature recorded due to temperature of {}", *max),
                        ),

                        Err(err) => logger::log(
                            Level::Error,
                            "module-enrichment/map",
                            &format!(
                                "failed to set value for over-temperature key '{OVERTEMP_KEY}': {err}"
                            ),
                        ),
                    }
                    increase_overtemp_count();
                } else if *min < 0.0 {
                    *overtemp = false;

                    match state_store::set(OVERTEMP_KEY.as_bytes(), b"false", None, None, SetOptions::default()) {
                        Ok(_) => logger::log(
                            Level::Info,
                            "module-enrichment/map",
                            &format!("over-temperature cleared due to temperature of {}", *min),
                        ),

                        Err(err) => logger::log(
                            Level::Error,
                            "module-enrichment/map",
                            &format!(
                                "failed to set value for over-temperature key '{OVERTEMP_KEY}': {err}"
                            ),
                        ),
                    }
                } else {
                    match state_store::get(OVERTEMP_KEY.as_bytes(), None).as_ref().map(|value| value.response.as_deref()) {
                        Ok(Some(b"true")) => {
                            logger::log(
                                Level::Warn,
                                "module-enrichment/map",
                                "over-temperature was recorded earlier",
                            );
                            *overtemp = true;
                        }

                        // Retain original overtemp value.
                        Ok(Some(b"false") | None) => (),

                        Ok(Some(value)) => logger::log(
                            Level::Warn,
                            "module-enrichment/map",
                            &format!("over-temperature key '{OVERTEMP_KEY}' has unexpected value '{value:?}'"),
                        ),

                        Err(err) => logger::log(
                            Level::Error,
                            "module-enrichment/map",
                            &format!("failed to get value for over-temperature key '{OVERTEMP_KEY}': {err}"),
                        ),
                    }
                }

                *value = None;
            }

            for humidity in sensor_data.humidity() {
                let MeasurementHumidity {
                    value: _,
                    count: _,
                    max,
                    min,
                    average: _,
                    last: _,
                } = humidity;

                if *max > 80.0 {
                    match state_store::set(
                        WET_FLAG.as_bytes(),
                        max.to_string().as_bytes(),
                        None,
                        None,
                        SetOptions::default(),
                    ) {
                        Ok(_) => logger::log(
                            Level::Warn,
                            "module2/map",
                            &format!("wet flag recorded due to humidity of {}", *max),
                        ),

                        Err(err) => logger::log(
                            Level::Error,
                            "module2/map",
                            &format!("failed to set wet flag '{WET_FLAG}': {err}"),
                        ),
                    }
                } else if *min < 80.0 {
                    match state_store::del(WET_FLAG.as_bytes(), None, None) {
                        Ok(res) => {
                            if res.response > 0 {
                                logger::log(Level::Info, "module2/map", "wet flag deleted.");
                            }
                        }

                        Err(err) => logger::log(
                            Level::Error,
                            "module2/map",
                            &format!("failed to delete wet flag '{WET_FLAG}': {err}"),
                        ),
                    }
                }
            }

            // Return processed sensor data
            sensor_data
        }
        _ => {
            panic!("Unexpected type for result.");
        }
    };

    let payload = serde_json::to_vec(&sensor_data).unwrap();
    result.payload = BufferOrBytes::Bytes(payload);

    DataModel::Message(result)
}

fn get_lock(lock_name: &str) -> Result<StateStoreHybridLogicalClock, ()> {
    logger::log(
        Level::Info,
        "module2/map",
        &format!("acquiring lock '{lock_name}'"),
    );
    let res = state_store::set(
        lock_name.as_bytes(),
        b"module2",
        None,
        None,
        SetOptions {
            conditions: SetConditions::OnlyIfEqualOrDoesNotExist,
            expires: Some(tinykube_wasm_sdk::state_store::Duration {
                seconds: 10,
                nanos: 0,
            }),
        },
    );
    match res {
        Ok(res) => {
            if res.response {
                Ok(res.version.unwrap())
            } else {
                Err(())
            }
        }
        Err(_) => Err(()),
    }
}

fn release_lock(lock_name: &str) {
    logger::log(
        Level::Info,
        "module2/map",
        &format!("releasing lock '{lock_name}'"),
    );
    let _ = state_store::vdel(lock_name.as_bytes(), b"module2", None, None);
}

fn increase_overtemp_count() {
    const OVERTEMP_COUNT_KEY: &str = "overtemp_count";
    const LOCK_KEY: &str = "lock";

    let mut retries = 3;
    while retries > 0 {
        retries -= 1;
        if let Ok(ft) = get_lock(LOCK_KEY) {
            logger::log(Level::Info, "module2/map", "lock acquired");
            match state_store::get(OVERTEMP_COUNT_KEY.as_bytes(),None).as_ref().map(|value| value.response.as_deref()) {
                Ok(value) => {
                    let count = std::str::from_utf8(value.unwrap_or(b"0")).unwrap().parse::<u64>().unwrap();
                    let new_count = count + 1;
                    match state_store::set(OVERTEMP_COUNT_KEY.as_bytes(), new_count.to_string().as_bytes(), None, Some(&ft), SetOptions::default()) {
                        Ok(res) => {
                            if res.response { logger::log(
                                    Level::Info,
                                    "module2/map",
                                    &format!("over-temperature count updated to {new_count}"),
                            ); } else {
                                    logger::log(
                                    Level::Warn,
                                    "module2/map",
                                    "over-temperature count was updated by another module",
                                    );
                                    continue;
                                }
                            }

                        Err(err) => {
                            logger::log(
                            Level::Error,
                            "module2/map",
                            &format!(
                                "failed to set value for over-temperature count key '{OVERTEMP_COUNT_KEY}': {err}"
                            ));
                            continue;
                        }
                    }
                }

                Err(err) => logger::log(
                    Level::Error,
                    "module2/map",
                    &format!("failed to get value for over-temperature count key '{OVERTEMP_COUNT_KEY}': {err}"),
                ),
            }
            release_lock(LOCK_KEY);
            break;
        }
        logger::log(
            Level::Warn,
            "module2/map",
            &format!("failed to acquire lock, retries left: {retries}"),
        );
        if retries == 0 {
            logger::log(
                Level::Error,
                "module2/map",
                "failed to acquire lock after multiple attempts",
            );
        }
    }
}

#[derive(Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub enum Measurement {
    #[serde(rename = "temperature")]
    Temperature(MeasurementTemperature),

    #[serde(rename = "humidity")]
    Humidity(MeasurementHumidity),

    #[serde(rename = "object")]
    Object(MeasurementObject),

    #[serde(rename = "sensor_data")]
    SensorData(MeasurementSensorData),
}

#[derive(Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct MeasurementTemperature {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<f64>,
    #[serde(default)]
    pub count: u64,
    #[serde(default)]
    pub max: f64,
    #[serde(default)]
    pub min: f64,
    #[serde(default)]
    pub average: f64,
    #[serde(default)]
    pub last: f64,
    pub unit: MeasurementTemperatureUnit,
    #[serde(default)]
    pub overtemp: bool,
}

#[derive(Clone, Copy, Debug, Eq, PartialEq, serde::Deserialize, serde::Serialize)]
pub enum MeasurementTemperatureUnit {
    #[serde(rename = "C")]
    Celsius,

    #[serde(rename = "F")]
    Fahrenheit,
}

#[derive(Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct MeasurementHumidity {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<f64>,
    #[serde(default)]
    pub count: u64,
    #[serde(default)]
    pub max: f64,
    #[serde(default)]
    pub min: f64,
    #[serde(default)]
    pub average: f64,
    #[serde(default)]
    pub last: f64,
}

#[derive(Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct MeasurementObject {
    pub result: String,
}

#[derive(Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct MeasurementSensorData {
    #[serde(default)]
    pub temperature: Vec<MeasurementTemperature>,

    #[serde(default)]
    pub humidity: Vec<MeasurementHumidity>,

    #[serde(default)]
    pub object: Vec<MeasurementObject>,
}

impl Default for MeasurementSensorData {
    fn default() -> Self {
        Self::new()
    }
}

impl MeasurementSensorData {
    pub fn new() -> Self {
        Self {
            temperature: Vec::new(),
            humidity: Vec::new(),
            object: Vec::new(),
        }
    }

    pub fn temperature(&mut self) -> &mut [MeasurementTemperature] {
        &mut self.temperature
    }

    pub fn humidity(&mut self) -> &mut [MeasurementHumidity] {
        &mut self.humidity
    }

    pub fn object(&mut self) -> &mut [MeasurementObject] {
        &mut self.object
    }
}
