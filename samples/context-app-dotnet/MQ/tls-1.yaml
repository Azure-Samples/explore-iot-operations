## More complex deployment for the broker. This example file shows how to configure a listener with multiple ports,
## use a nodeport, enable authentication and authorization, and use a disk backed buffer.
## It deploys 2 frontends and 2 backend chains of length 2. Each pod has 2 workers available.

############################################################
##
## A at least one BrokerListener CR should be deployed before Broker,
## so that the Broker resource will not fail with missing BrokerListener.
##
############################################################
---
apiVersion: mqttbroker.iotoperations.azure.com/v1beta1
kind: BrokerListener
metadata:
  name: listener
  namespace: default
spec:
  brokerRef: broker
  serviceType: LoadBalancer
  serviceName: aio-mq-dmqtt-frontend
  ## This port will only be accessible within the cluster and has no authentication or authorization.
  ports:
  - port: 1883
  - port: 8883
    ## These values match the name of the BrokerAuthentication and BrokerAuthorization resources below.
    authenticationRef: authn-policies
    # Uncomment to enable TLS on the listener if cert-manager is enabled
    tls:
      mode: 'automatic'
      certManagerCertificateSpec:
        issuerRef:
          name: my-issuer
          kind: Issuer
      


############################################################
##
## This defines the broker itself
##
############################################################
---
apiVersion: mqttbroker.iotoperations.azure.com/v1beta1
kind: Broker
metadata:
  name: broker
  namespace: default
spec:
  advanced:
    ## Internal tls has a dependency on cert manager.
    encryptInternalTraffic: Disabled
  cardinality:
    frontend:
      ## This determines how many frontend pods are deployed. This scales both availability and reliability, but requires sufficient backend capacity to function.
      replicas: 2
      ## This determines how many workers each pod will create. More powerful nodes can support more workers in each pod.
      workers: 2
    backendChain:
      ## This determines how many pods will be in each backend chain. Increasing this improves availability but increases latency.
      ## As long as one pod in each backend chain is functional, the broker be fully functional and lose no messages.
      redundancyFactor: 2
      ## This is how the broker scales capacity. Increasing this will increase the volume of messages the broker can handle, as long as messages are evenly distributed among topics.
      partitions: 2
      ## This determines how many workers each pod will create.
      workers: 2
  ## This will check that there are enough cores available on the cluster for each worker to have its own.
  generateResourceLimits:
    cpu: Disabled
  ## Possible values
  ## - Tiny
  ## - Low
  ## - Medium (default)
  ## - High
  memoryProfile: "Medium"

  ## Uncomment one of these to enable the disk-backed message buffer.
  ##
  ## Option 1: emptyDir volume
  ##
  diskBackedMessageBuffer:
    maxSize: '1M'

  ## Option 2: Persistent volume using specified claim template
  ##
  # diskBackedMessageBuffer:
  #   maxSize: '1M'
  #   persistentVolumeClaimSpec:
  #     ## Default storage class `rancher.io/local-path` on k3d
  #     ## storageClassName: 'foo'
  #     accessModes:
  #     - 'ReadWriteOnce'

  ## Option 3: Ephemeral volume using specified claim template
  ##
  # diskBackedMessageBuffer:
  #   maxSize: '1M'
  #
  #   ephemeralVolumeClaimSpec:
  #     ## Default storage class `rancher.io/local-path` on k3d
  #     ## storageClassName: 'foo'
  #     accessModes:
  #     - 'ReadWriteOnce'


############################################################
##
## Note: make sure the `BrokerListener` has an `authenticationRef` referring to this
## `BrokerAuthentication`.
##
## Details: https://learn.microsoft.com/azure/iot-operations/manage-mqtt-connectivity/howto-configure-authentication#relationship-between-brokerlistener-and-brokerauthentication
##
############################################################
---
apiVersion: mqttbroker.iotoperations.azure.com/v1beta1
kind: BrokerAuthentication
metadata:
  name: "authn-policies"
  namespace: default
spec:
  authenticationMethods:

    ## See: ## See: https://learn.microsoft.com/azure/iot-operations/manage-mqtt-connectivity/howto-configure-authentication#x509-client-certificate
    - method: serviceAccountToken
      serviceAccountTokenSettings:
        audiences: ["aio-mq"]

    # Make sure enable TLS on the listener first
    #
    # See: https://learn.microsoft.com/azure/iot-operations/manage-mqtt-connectivity/howto-configure-authentication#x509-client-certificate
    # Uncomment this if cern-manager is enabled on the cluster
    - method: x509Credentials
      x509Settings:
        trustedClientCaCert: client-ca