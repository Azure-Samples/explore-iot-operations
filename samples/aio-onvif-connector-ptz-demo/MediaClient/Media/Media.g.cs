/* Code generated by Azure.Iot.Operations.ProtocolCompiler v0.10.0.0; DO NOT EDIT. */

#nullable enable

namespace MediaClient.Media
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading;
    using System.Threading.Tasks;
    using Azure.Iot.Operations.Protocol.Models;
    using Azure.Iot.Operations.Protocol;
    using Azure.Iot.Operations.Protocol.RPC;
    using Azure.Iot.Operations.Protocol.Telemetry;
    using MediaClient;

    [CommandTopic("{ex:namespace}/mrpc/{ex:asset}/{commandName}")]
    [System.CodeDom.Compiler.GeneratedCode("Azure.Iot.Operations.ProtocolCompiler", "0.10.0.0")]
    public static partial class Media
    {
        public abstract partial class Client : IAsyncDisposable
        {
            private ApplicationContext applicationContext;
            private IMqttPubSubClient mqttClient;
            private readonly GetProfileCommandInvoker getProfileCommandInvoker;
            private readonly GetProfilesCommandInvoker getProfilesCommandInvoker;
            private readonly CreateProfileCommandInvoker createProfileCommandInvoker;
            private readonly DeleteProfileCommandInvoker deleteProfileCommandInvoker;
            private readonly GetVideoEncoderConfigurationCommandInvoker getVideoEncoderConfigurationCommandInvoker;
            private readonly GetVideoEncoderConfigurationsCommandInvoker getVideoEncoderConfigurationsCommandInvoker;
            private readonly AddVideoEncoderConfigurationCommandInvoker addVideoEncoderConfigurationCommandInvoker;
            private readonly RemoveVideoEncoderConfigurationCommandInvoker removeVideoEncoderConfigurationCommandInvoker;
            private readonly SetVideoEncoderConfigurationCommandInvoker setVideoEncoderConfigurationCommandInvoker;
            private readonly GetCompatibleVideoEncoderConfigurationsCommandInvoker getCompatibleVideoEncoderConfigurationsCommandInvoker;
            private readonly GetVideoEncoderConfigurationOptionsCommandInvoker getVideoEncoderConfigurationOptionsCommandInvoker;
            private readonly GetGuaranteedNumberOfVideoEncoderInstancesCommandInvoker getGuaranteedNumberOfVideoEncoderInstancesCommandInvoker;
            private readonly GetVideoSourcesCommandInvoker getVideoSourcesCommandInvoker;
            private readonly GetVideoSourceConfigurationCommandInvoker getVideoSourceConfigurationCommandInvoker;
            private readonly GetVideoSourceConfigurationsCommandInvoker getVideoSourceConfigurationsCommandInvoker;
            private readonly AddVideoSourceConfigurationCommandInvoker addVideoSourceConfigurationCommandInvoker;
            private readonly RemoveVideoSourceConfigurationCommandInvoker removeVideoSourceConfigurationCommandInvoker;
            private readonly SetVideoSourceConfigurationCommandInvoker setVideoSourceConfigurationCommandInvoker;
            private readonly GetCompatibleVideoSourceConfigurationsCommandInvoker getCompatibleVideoSourceConfigurationsCommandInvoker;
            private readonly GetVideoSourceConfigurationOptionsCommandInvoker getVideoSourceConfigurationOptionsCommandInvoker;
            private readonly GetMetadataConfigurationCommandInvoker getMetadataConfigurationCommandInvoker;
            private readonly GetMetadataConfigurationsCommandInvoker getMetadataConfigurationsCommandInvoker;
            private readonly GetCompatibleMetadataConfigurationsCommandInvoker getCompatibleMetadataConfigurationsCommandInvoker;
            private readonly AddMetadataConfigurationCommandInvoker addMetadataConfigurationCommandInvoker;
            private readonly SetMetadataConfigurationCommandInvoker setMetadataConfigurationCommandInvoker;
            private readonly RemoveMetadataConfigurationCommandInvoker removeMetadataConfigurationCommandInvoker;
            private readonly GetMetadataConfigurationOptionsCommandInvoker getMetadataConfigurationOptionsCommandInvoker;
            private readonly SetSynchronizationPointCommandInvoker setSynchronizationPointCommandInvoker;
            private readonly AddPtzconfigurationCommandInvoker addPtzconfigurationCommandInvoker;
            private readonly RemovePtzconfigurationCommandInvoker removePtzconfigurationCommandInvoker;
            private readonly GetAudioSourcesCommandInvoker getAudioSourcesCommandInvoker;
            private readonly GetAudioSourceConfigurationCommandInvoker getAudioSourceConfigurationCommandInvoker;
            private readonly GetAudioSourceConfigurationsCommandInvoker getAudioSourceConfigurationsCommandInvoker;
            private readonly AddAudioSourceConfigurationCommandInvoker addAudioSourceConfigurationCommandInvoker;
            private readonly RemoveAudioSourceConfigurationCommandInvoker removeAudioSourceConfigurationCommandInvoker;
            private readonly SetAudioSourceConfigurationCommandInvoker setAudioSourceConfigurationCommandInvoker;
            private readonly GetAudioSourceConfigurationOptionsCommandInvoker getAudioSourceConfigurationOptionsCommandInvoker;
            private readonly GetCompatibleAudioSourceConfigurationsCommandInvoker getCompatibleAudioSourceConfigurationsCommandInvoker;
            private readonly GetAudioEncoderConfigurationCommandInvoker getAudioEncoderConfigurationCommandInvoker;
            private readonly GetAudioEncoderConfigurationsCommandInvoker getAudioEncoderConfigurationsCommandInvoker;
            private readonly AddAudioEncoderConfigurationCommandInvoker addAudioEncoderConfigurationCommandInvoker;
            private readonly RemoveAudioEncoderConfigurationCommandInvoker removeAudioEncoderConfigurationCommandInvoker;
            private readonly SetAudioEncoderConfigurationCommandInvoker setAudioEncoderConfigurationCommandInvoker;
            private readonly GetCompatibleAudioEncoderConfigurationsCommandInvoker getCompatibleAudioEncoderConfigurationsCommandInvoker;
            private readonly GetAudioEncoderConfigurationOptionsCommandInvoker getAudioEncoderConfigurationOptionsCommandInvoker;
            private readonly StartMulticastStreamingCommandInvoker startMulticastStreamingCommandInvoker;

            /// <summary>
            /// Construct a new instance of this client.
            /// </summary>
            /// <param name="applicationContext">The shared context for your application.</param>
            /// <param name="mqttClient">The MQTT client to use.</param>
            /// <param name="topicTokenMap">
            /// The topic token replacement map to use for all operations by default. Generally, this will include the token values
            /// for topic tokens such as "modelId" which should be the same for the duration of this client's lifetime. Note that
            /// additional topic tokens can be specified when starting the client with <see cref="StartAsync(Dictionary{string, string}?, int?, CancellationToken)"/>.
            /// </param>
            public Client(ApplicationContext applicationContext, IMqttPubSubClient mqttClient, Dictionary<string, string>? topicTokenMap = null)
            {
                this.applicationContext = applicationContext;
                this.mqttClient = mqttClient;

                this.getProfileCommandInvoker = new GetProfileCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getProfileCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getProfilesCommandInvoker = new GetProfilesCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getProfilesCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.createProfileCommandInvoker = new CreateProfileCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.createProfileCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.deleteProfileCommandInvoker = new DeleteProfileCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.deleteProfileCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getVideoEncoderConfigurationCommandInvoker = new GetVideoEncoderConfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getVideoEncoderConfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getVideoEncoderConfigurationsCommandInvoker = new GetVideoEncoderConfigurationsCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getVideoEncoderConfigurationsCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.addVideoEncoderConfigurationCommandInvoker = new AddVideoEncoderConfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.addVideoEncoderConfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.removeVideoEncoderConfigurationCommandInvoker = new RemoveVideoEncoderConfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.removeVideoEncoderConfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.setVideoEncoderConfigurationCommandInvoker = new SetVideoEncoderConfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.setVideoEncoderConfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getCompatibleVideoEncoderConfigurationsCommandInvoker = new GetCompatibleVideoEncoderConfigurationsCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getCompatibleVideoEncoderConfigurationsCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getVideoEncoderConfigurationOptionsCommandInvoker = new GetVideoEncoderConfigurationOptionsCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getVideoEncoderConfigurationOptionsCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getGuaranteedNumberOfVideoEncoderInstancesCommandInvoker = new GetGuaranteedNumberOfVideoEncoderInstancesCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getGuaranteedNumberOfVideoEncoderInstancesCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getVideoSourcesCommandInvoker = new GetVideoSourcesCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getVideoSourcesCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getVideoSourceConfigurationCommandInvoker = new GetVideoSourceConfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getVideoSourceConfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getVideoSourceConfigurationsCommandInvoker = new GetVideoSourceConfigurationsCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getVideoSourceConfigurationsCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.addVideoSourceConfigurationCommandInvoker = new AddVideoSourceConfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.addVideoSourceConfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.removeVideoSourceConfigurationCommandInvoker = new RemoveVideoSourceConfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.removeVideoSourceConfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.setVideoSourceConfigurationCommandInvoker = new SetVideoSourceConfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.setVideoSourceConfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getCompatibleVideoSourceConfigurationsCommandInvoker = new GetCompatibleVideoSourceConfigurationsCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getCompatibleVideoSourceConfigurationsCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getVideoSourceConfigurationOptionsCommandInvoker = new GetVideoSourceConfigurationOptionsCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getVideoSourceConfigurationOptionsCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getMetadataConfigurationCommandInvoker = new GetMetadataConfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getMetadataConfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getMetadataConfigurationsCommandInvoker = new GetMetadataConfigurationsCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getMetadataConfigurationsCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getCompatibleMetadataConfigurationsCommandInvoker = new GetCompatibleMetadataConfigurationsCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getCompatibleMetadataConfigurationsCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.addMetadataConfigurationCommandInvoker = new AddMetadataConfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.addMetadataConfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.setMetadataConfigurationCommandInvoker = new SetMetadataConfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.setMetadataConfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.removeMetadataConfigurationCommandInvoker = new RemoveMetadataConfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.removeMetadataConfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getMetadataConfigurationOptionsCommandInvoker = new GetMetadataConfigurationOptionsCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getMetadataConfigurationOptionsCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.setSynchronizationPointCommandInvoker = new SetSynchronizationPointCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.setSynchronizationPointCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.addPtzconfigurationCommandInvoker = new AddPtzconfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.addPtzconfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.removePtzconfigurationCommandInvoker = new RemovePtzconfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.removePtzconfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getAudioSourcesCommandInvoker = new GetAudioSourcesCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getAudioSourcesCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getAudioSourceConfigurationCommandInvoker = new GetAudioSourceConfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getAudioSourceConfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getAudioSourceConfigurationsCommandInvoker = new GetAudioSourceConfigurationsCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getAudioSourceConfigurationsCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.addAudioSourceConfigurationCommandInvoker = new AddAudioSourceConfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.addAudioSourceConfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.removeAudioSourceConfigurationCommandInvoker = new RemoveAudioSourceConfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.removeAudioSourceConfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.setAudioSourceConfigurationCommandInvoker = new SetAudioSourceConfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.setAudioSourceConfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getAudioSourceConfigurationOptionsCommandInvoker = new GetAudioSourceConfigurationOptionsCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getAudioSourceConfigurationOptionsCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getCompatibleAudioSourceConfigurationsCommandInvoker = new GetCompatibleAudioSourceConfigurationsCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getCompatibleAudioSourceConfigurationsCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getAudioEncoderConfigurationCommandInvoker = new GetAudioEncoderConfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getAudioEncoderConfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getAudioEncoderConfigurationsCommandInvoker = new GetAudioEncoderConfigurationsCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getAudioEncoderConfigurationsCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.addAudioEncoderConfigurationCommandInvoker = new AddAudioEncoderConfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.addAudioEncoderConfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.removeAudioEncoderConfigurationCommandInvoker = new RemoveAudioEncoderConfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.removeAudioEncoderConfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.setAudioEncoderConfigurationCommandInvoker = new SetAudioEncoderConfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.setAudioEncoderConfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getCompatibleAudioEncoderConfigurationsCommandInvoker = new GetCompatibleAudioEncoderConfigurationsCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getCompatibleAudioEncoderConfigurationsCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getAudioEncoderConfigurationOptionsCommandInvoker = new GetAudioEncoderConfigurationOptionsCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getAudioEncoderConfigurationOptionsCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.startMulticastStreamingCommandInvoker = new StartMulticastStreamingCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.startMulticastStreamingCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
            }

            public GetProfileCommandInvoker GetProfileCommandInvoker { get => this.getProfileCommandInvoker; }

            public GetProfilesCommandInvoker GetProfilesCommandInvoker { get => this.getProfilesCommandInvoker; }

            public CreateProfileCommandInvoker CreateProfileCommandInvoker { get => this.createProfileCommandInvoker; }

            public DeleteProfileCommandInvoker DeleteProfileCommandInvoker { get => this.deleteProfileCommandInvoker; }

            public GetVideoEncoderConfigurationCommandInvoker GetVideoEncoderConfigurationCommandInvoker { get => this.getVideoEncoderConfigurationCommandInvoker; }

            public GetVideoEncoderConfigurationsCommandInvoker GetVideoEncoderConfigurationsCommandInvoker { get => this.getVideoEncoderConfigurationsCommandInvoker; }

            public AddVideoEncoderConfigurationCommandInvoker AddVideoEncoderConfigurationCommandInvoker { get => this.addVideoEncoderConfigurationCommandInvoker; }

            public RemoveVideoEncoderConfigurationCommandInvoker RemoveVideoEncoderConfigurationCommandInvoker { get => this.removeVideoEncoderConfigurationCommandInvoker; }

            public SetVideoEncoderConfigurationCommandInvoker SetVideoEncoderConfigurationCommandInvoker { get => this.setVideoEncoderConfigurationCommandInvoker; }

            public GetCompatibleVideoEncoderConfigurationsCommandInvoker GetCompatibleVideoEncoderConfigurationsCommandInvoker { get => this.getCompatibleVideoEncoderConfigurationsCommandInvoker; }

            public GetVideoEncoderConfigurationOptionsCommandInvoker GetVideoEncoderConfigurationOptionsCommandInvoker { get => this.getVideoEncoderConfigurationOptionsCommandInvoker; }

            public GetGuaranteedNumberOfVideoEncoderInstancesCommandInvoker GetGuaranteedNumberOfVideoEncoderInstancesCommandInvoker { get => this.getGuaranteedNumberOfVideoEncoderInstancesCommandInvoker; }

            public GetVideoSourcesCommandInvoker GetVideoSourcesCommandInvoker { get => this.getVideoSourcesCommandInvoker; }

            public GetVideoSourceConfigurationCommandInvoker GetVideoSourceConfigurationCommandInvoker { get => this.getVideoSourceConfigurationCommandInvoker; }

            public GetVideoSourceConfigurationsCommandInvoker GetVideoSourceConfigurationsCommandInvoker { get => this.getVideoSourceConfigurationsCommandInvoker; }

            public AddVideoSourceConfigurationCommandInvoker AddVideoSourceConfigurationCommandInvoker { get => this.addVideoSourceConfigurationCommandInvoker; }

            public RemoveVideoSourceConfigurationCommandInvoker RemoveVideoSourceConfigurationCommandInvoker { get => this.removeVideoSourceConfigurationCommandInvoker; }

            public SetVideoSourceConfigurationCommandInvoker SetVideoSourceConfigurationCommandInvoker { get => this.setVideoSourceConfigurationCommandInvoker; }

            public GetCompatibleVideoSourceConfigurationsCommandInvoker GetCompatibleVideoSourceConfigurationsCommandInvoker { get => this.getCompatibleVideoSourceConfigurationsCommandInvoker; }

            public GetVideoSourceConfigurationOptionsCommandInvoker GetVideoSourceConfigurationOptionsCommandInvoker { get => this.getVideoSourceConfigurationOptionsCommandInvoker; }

            public GetMetadataConfigurationCommandInvoker GetMetadataConfigurationCommandInvoker { get => this.getMetadataConfigurationCommandInvoker; }

            public GetMetadataConfigurationsCommandInvoker GetMetadataConfigurationsCommandInvoker { get => this.getMetadataConfigurationsCommandInvoker; }

            public GetCompatibleMetadataConfigurationsCommandInvoker GetCompatibleMetadataConfigurationsCommandInvoker { get => this.getCompatibleMetadataConfigurationsCommandInvoker; }

            public AddMetadataConfigurationCommandInvoker AddMetadataConfigurationCommandInvoker { get => this.addMetadataConfigurationCommandInvoker; }

            public SetMetadataConfigurationCommandInvoker SetMetadataConfigurationCommandInvoker { get => this.setMetadataConfigurationCommandInvoker; }

            public RemoveMetadataConfigurationCommandInvoker RemoveMetadataConfigurationCommandInvoker { get => this.removeMetadataConfigurationCommandInvoker; }

            public GetMetadataConfigurationOptionsCommandInvoker GetMetadataConfigurationOptionsCommandInvoker { get => this.getMetadataConfigurationOptionsCommandInvoker; }

            public SetSynchronizationPointCommandInvoker SetSynchronizationPointCommandInvoker { get => this.setSynchronizationPointCommandInvoker; }

            public AddPtzconfigurationCommandInvoker AddPtzconfigurationCommandInvoker { get => this.addPtzconfigurationCommandInvoker; }

            public RemovePtzconfigurationCommandInvoker RemovePtzconfigurationCommandInvoker { get => this.removePtzconfigurationCommandInvoker; }

            public GetAudioSourcesCommandInvoker GetAudioSourcesCommandInvoker { get => this.getAudioSourcesCommandInvoker; }

            public GetAudioSourceConfigurationCommandInvoker GetAudioSourceConfigurationCommandInvoker { get => this.getAudioSourceConfigurationCommandInvoker; }

            public GetAudioSourceConfigurationsCommandInvoker GetAudioSourceConfigurationsCommandInvoker { get => this.getAudioSourceConfigurationsCommandInvoker; }

            public AddAudioSourceConfigurationCommandInvoker AddAudioSourceConfigurationCommandInvoker { get => this.addAudioSourceConfigurationCommandInvoker; }

            public RemoveAudioSourceConfigurationCommandInvoker RemoveAudioSourceConfigurationCommandInvoker { get => this.removeAudioSourceConfigurationCommandInvoker; }

            public SetAudioSourceConfigurationCommandInvoker SetAudioSourceConfigurationCommandInvoker { get => this.setAudioSourceConfigurationCommandInvoker; }

            public GetAudioSourceConfigurationOptionsCommandInvoker GetAudioSourceConfigurationOptionsCommandInvoker { get => this.getAudioSourceConfigurationOptionsCommandInvoker; }

            public GetCompatibleAudioSourceConfigurationsCommandInvoker GetCompatibleAudioSourceConfigurationsCommandInvoker { get => this.getCompatibleAudioSourceConfigurationsCommandInvoker; }

            public GetAudioEncoderConfigurationCommandInvoker GetAudioEncoderConfigurationCommandInvoker { get => this.getAudioEncoderConfigurationCommandInvoker; }

            public GetAudioEncoderConfigurationsCommandInvoker GetAudioEncoderConfigurationsCommandInvoker { get => this.getAudioEncoderConfigurationsCommandInvoker; }

            public AddAudioEncoderConfigurationCommandInvoker AddAudioEncoderConfigurationCommandInvoker { get => this.addAudioEncoderConfigurationCommandInvoker; }

            public RemoveAudioEncoderConfigurationCommandInvoker RemoveAudioEncoderConfigurationCommandInvoker { get => this.removeAudioEncoderConfigurationCommandInvoker; }

            public SetAudioEncoderConfigurationCommandInvoker SetAudioEncoderConfigurationCommandInvoker { get => this.setAudioEncoderConfigurationCommandInvoker; }

            public GetCompatibleAudioEncoderConfigurationsCommandInvoker GetCompatibleAudioEncoderConfigurationsCommandInvoker { get => this.getCompatibleAudioEncoderConfigurationsCommandInvoker; }

            public GetAudioEncoderConfigurationOptionsCommandInvoker GetAudioEncoderConfigurationOptionsCommandInvoker { get => this.getAudioEncoderConfigurationOptionsCommandInvoker; }

            public StartMulticastStreamingCommandInvoker StartMulticastStreamingCommandInvoker { get => this.startMulticastStreamingCommandInvoker; }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetProfileResponsePayload> GetProfileAsync(GetProfileRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetProfileResponsePayload>(this.GetProfileInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetProfilesResponsePayload> GetProfilesAsync(CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetProfilesResponsePayload>(this.GetProfilesInt(new EmptyJson(), metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<CreateProfileResponsePayload> CreateProfileAsync(CreateProfileRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<CreateProfileResponsePayload>(this.CreateProfileInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<DeleteProfileResponsePayload> DeleteProfileAsync(DeleteProfileRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<DeleteProfileResponsePayload>(this.DeleteProfileInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetVideoEncoderConfigurationResponsePayload> GetVideoEncoderConfigurationAsync(GetVideoEncoderConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetVideoEncoderConfigurationResponsePayload>(this.GetVideoEncoderConfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetVideoEncoderConfigurationsResponsePayload> GetVideoEncoderConfigurationsAsync(CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetVideoEncoderConfigurationsResponsePayload>(this.GetVideoEncoderConfigurationsInt(new EmptyJson(), metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<AddVideoEncoderConfigurationResponsePayload> AddVideoEncoderConfigurationAsync(AddVideoEncoderConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<AddVideoEncoderConfigurationResponsePayload>(this.AddVideoEncoderConfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<RemoveVideoEncoderConfigurationResponsePayload> RemoveVideoEncoderConfigurationAsync(RemoveVideoEncoderConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<RemoveVideoEncoderConfigurationResponsePayload>(this.RemoveVideoEncoderConfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<SetVideoEncoderConfigurationResponsePayload> SetVideoEncoderConfigurationAsync(SetVideoEncoderConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<SetVideoEncoderConfigurationResponsePayload>(this.SetVideoEncoderConfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetCompatibleVideoEncoderConfigurationsResponsePayload> GetCompatibleVideoEncoderConfigurationsAsync(GetCompatibleVideoEncoderConfigurationsRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetCompatibleVideoEncoderConfigurationsResponsePayload>(this.GetCompatibleVideoEncoderConfigurationsInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetVideoEncoderConfigurationOptionsResponsePayload> GetVideoEncoderConfigurationOptionsAsync(GetVideoEncoderConfigurationOptionsRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetVideoEncoderConfigurationOptionsResponsePayload>(this.GetVideoEncoderConfigurationOptionsInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetGuaranteedNumberOfVideoEncoderInstancesResponsePayload> GetGuaranteedNumberOfVideoEncoderInstancesAsync(GetGuaranteedNumberOfVideoEncoderInstancesRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetGuaranteedNumberOfVideoEncoderInstancesResponsePayload>(this.GetGuaranteedNumberOfVideoEncoderInstancesInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetVideoSourcesResponsePayload> GetVideoSourcesAsync(CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetVideoSourcesResponsePayload>(this.GetVideoSourcesInt(new EmptyJson(), metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetVideoSourceConfigurationResponsePayload> GetVideoSourceConfigurationAsync(GetVideoSourceConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetVideoSourceConfigurationResponsePayload>(this.GetVideoSourceConfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetVideoSourceConfigurationsResponsePayload> GetVideoSourceConfigurationsAsync(CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetVideoSourceConfigurationsResponsePayload>(this.GetVideoSourceConfigurationsInt(new EmptyJson(), metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<AddVideoSourceConfigurationResponsePayload> AddVideoSourceConfigurationAsync(AddVideoSourceConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<AddVideoSourceConfigurationResponsePayload>(this.AddVideoSourceConfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<RemoveVideoSourceConfigurationResponsePayload> RemoveVideoSourceConfigurationAsync(RemoveVideoSourceConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<RemoveVideoSourceConfigurationResponsePayload>(this.RemoveVideoSourceConfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<SetVideoSourceConfigurationResponsePayload> SetVideoSourceConfigurationAsync(SetVideoSourceConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<SetVideoSourceConfigurationResponsePayload>(this.SetVideoSourceConfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetCompatibleVideoSourceConfigurationsResponsePayload> GetCompatibleVideoSourceConfigurationsAsync(GetCompatibleVideoSourceConfigurationsRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetCompatibleVideoSourceConfigurationsResponsePayload>(this.GetCompatibleVideoSourceConfigurationsInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetVideoSourceConfigurationOptionsResponsePayload> GetVideoSourceConfigurationOptionsAsync(GetVideoSourceConfigurationOptionsRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetVideoSourceConfigurationOptionsResponsePayload>(this.GetVideoSourceConfigurationOptionsInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetMetadataConfigurationResponsePayload> GetMetadataConfigurationAsync(GetMetadataConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetMetadataConfigurationResponsePayload>(this.GetMetadataConfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetMetadataConfigurationsResponsePayload> GetMetadataConfigurationsAsync(CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetMetadataConfigurationsResponsePayload>(this.GetMetadataConfigurationsInt(new EmptyJson(), metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetCompatibleMetadataConfigurationsResponsePayload> GetCompatibleMetadataConfigurationsAsync(GetCompatibleMetadataConfigurationsRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetCompatibleMetadataConfigurationsResponsePayload>(this.GetCompatibleMetadataConfigurationsInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<AddMetadataConfigurationResponsePayload> AddMetadataConfigurationAsync(AddMetadataConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<AddMetadataConfigurationResponsePayload>(this.AddMetadataConfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<SetMetadataConfigurationResponsePayload> SetMetadataConfigurationAsync(SetMetadataConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<SetMetadataConfigurationResponsePayload>(this.SetMetadataConfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<RemoveMetadataConfigurationResponsePayload> RemoveMetadataConfigurationAsync(RemoveMetadataConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<RemoveMetadataConfigurationResponsePayload>(this.RemoveMetadataConfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetMetadataConfigurationOptionsResponsePayload> GetMetadataConfigurationOptionsAsync(GetMetadataConfigurationOptionsRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetMetadataConfigurationOptionsResponsePayload>(this.GetMetadataConfigurationOptionsInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<SetSynchronizationPointResponsePayload> SetSynchronizationPointAsync(SetSynchronizationPointRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<SetSynchronizationPointResponsePayload>(this.SetSynchronizationPointInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<AddPtzconfigurationResponsePayload> AddPtzconfigurationAsync(AddPtzconfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<AddPtzconfigurationResponsePayload>(this.AddPtzconfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<RemovePtzconfigurationResponsePayload> RemovePtzconfigurationAsync(RemovePtzconfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<RemovePtzconfigurationResponsePayload>(this.RemovePtzconfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetAudioSourcesResponsePayload> GetAudioSourcesAsync(CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetAudioSourcesResponsePayload>(this.GetAudioSourcesInt(new EmptyJson(), metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetAudioSourceConfigurationResponsePayload> GetAudioSourceConfigurationAsync(GetAudioSourceConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetAudioSourceConfigurationResponsePayload>(this.GetAudioSourceConfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetAudioSourceConfigurationsResponsePayload> GetAudioSourceConfigurationsAsync(CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetAudioSourceConfigurationsResponsePayload>(this.GetAudioSourceConfigurationsInt(new EmptyJson(), metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<AddAudioSourceConfigurationResponsePayload> AddAudioSourceConfigurationAsync(AddAudioSourceConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<AddAudioSourceConfigurationResponsePayload>(this.AddAudioSourceConfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<RemoveAudioSourceConfigurationResponsePayload> RemoveAudioSourceConfigurationAsync(RemoveAudioSourceConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<RemoveAudioSourceConfigurationResponsePayload>(this.RemoveAudioSourceConfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<SetAudioSourceConfigurationResponsePayload> SetAudioSourceConfigurationAsync(SetAudioSourceConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<SetAudioSourceConfigurationResponsePayload>(this.SetAudioSourceConfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetAudioSourceConfigurationOptionsResponsePayload> GetAudioSourceConfigurationOptionsAsync(GetAudioSourceConfigurationOptionsRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetAudioSourceConfigurationOptionsResponsePayload>(this.GetAudioSourceConfigurationOptionsInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetCompatibleAudioSourceConfigurationsResponsePayload> GetCompatibleAudioSourceConfigurationsAsync(GetCompatibleAudioSourceConfigurationsRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetCompatibleAudioSourceConfigurationsResponsePayload>(this.GetCompatibleAudioSourceConfigurationsInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetAudioEncoderConfigurationResponsePayload> GetAudioEncoderConfigurationAsync(GetAudioEncoderConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetAudioEncoderConfigurationResponsePayload>(this.GetAudioEncoderConfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetAudioEncoderConfigurationsResponsePayload> GetAudioEncoderConfigurationsAsync(CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetAudioEncoderConfigurationsResponsePayload>(this.GetAudioEncoderConfigurationsInt(new EmptyJson(), metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<AddAudioEncoderConfigurationResponsePayload> AddAudioEncoderConfigurationAsync(AddAudioEncoderConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<AddAudioEncoderConfigurationResponsePayload>(this.AddAudioEncoderConfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<RemoveAudioEncoderConfigurationResponsePayload> RemoveAudioEncoderConfigurationAsync(RemoveAudioEncoderConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<RemoveAudioEncoderConfigurationResponsePayload>(this.RemoveAudioEncoderConfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<SetAudioEncoderConfigurationResponsePayload> SetAudioEncoderConfigurationAsync(SetAudioEncoderConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<SetAudioEncoderConfigurationResponsePayload>(this.SetAudioEncoderConfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetCompatibleAudioEncoderConfigurationsResponsePayload> GetCompatibleAudioEncoderConfigurationsAsync(GetCompatibleAudioEncoderConfigurationsRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetCompatibleAudioEncoderConfigurationsResponsePayload>(this.GetCompatibleAudioEncoderConfigurationsInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetAudioEncoderConfigurationOptionsResponsePayload> GetAudioEncoderConfigurationOptionsAsync(GetAudioEncoderConfigurationOptionsRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetAudioEncoderConfigurationOptionsResponsePayload>(this.GetAudioEncoderConfigurationOptionsInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<StartMulticastStreamingResponsePayload> StartMulticastStreamingAsync(StartMulticastStreamingRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<StartMulticastStreamingResponsePayload>(this.StartMulticastStreamingInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            private async Task<ExtendedResponse<GetProfileResponsePayload>> GetProfileInt(GetProfileRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetProfileResponseSchema> extended = await this.getProfileCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetProfileResponsePayload>
                    {
                        Response = new GetProfileResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetProfilesResponsePayload>> GetProfilesInt(EmptyJson request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetProfilesResponseSchema> extended = await this.getProfilesCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetProfilesResponsePayload>
                    {
                        Response = new GetProfilesResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<CreateProfileResponsePayload>> CreateProfileInt(CreateProfileRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<CreateProfileResponseSchema> extended = await this.createProfileCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<CreateProfileResponsePayload>
                    {
                        Response = new CreateProfileResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<DeleteProfileResponsePayload>> DeleteProfileInt(DeleteProfileRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<DeleteProfileResponseSchema> extended = await this.deleteProfileCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<DeleteProfileResponsePayload>
                    {
                        Response = new DeleteProfileResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetVideoEncoderConfigurationResponsePayload>> GetVideoEncoderConfigurationInt(GetVideoEncoderConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetVideoEncoderConfigurationResponseSchema> extended = await this.getVideoEncoderConfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetVideoEncoderConfigurationResponsePayload>
                    {
                        Response = new GetVideoEncoderConfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetVideoEncoderConfigurationsResponsePayload>> GetVideoEncoderConfigurationsInt(EmptyJson request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetVideoEncoderConfigurationsResponseSchema> extended = await this.getVideoEncoderConfigurationsCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetVideoEncoderConfigurationsResponsePayload>
                    {
                        Response = new GetVideoEncoderConfigurationsResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<AddVideoEncoderConfigurationResponsePayload>> AddVideoEncoderConfigurationInt(AddVideoEncoderConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<AddVideoEncoderConfigurationResponseSchema> extended = await this.addVideoEncoderConfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<AddVideoEncoderConfigurationResponsePayload>
                    {
                        Response = new AddVideoEncoderConfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<RemoveVideoEncoderConfigurationResponsePayload>> RemoveVideoEncoderConfigurationInt(RemoveVideoEncoderConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<RemoveVideoEncoderConfigurationResponseSchema> extended = await this.removeVideoEncoderConfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<RemoveVideoEncoderConfigurationResponsePayload>
                    {
                        Response = new RemoveVideoEncoderConfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<SetVideoEncoderConfigurationResponsePayload>> SetVideoEncoderConfigurationInt(SetVideoEncoderConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<SetVideoEncoderConfigurationResponseSchema> extended = await this.setVideoEncoderConfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<SetVideoEncoderConfigurationResponsePayload>
                    {
                        Response = new SetVideoEncoderConfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetCompatibleVideoEncoderConfigurationsResponsePayload>> GetCompatibleVideoEncoderConfigurationsInt(GetCompatibleVideoEncoderConfigurationsRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetCompatibleVideoEncoderConfigurationsResponseSchema> extended = await this.getCompatibleVideoEncoderConfigurationsCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetCompatibleVideoEncoderConfigurationsResponsePayload>
                    {
                        Response = new GetCompatibleVideoEncoderConfigurationsResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetVideoEncoderConfigurationOptionsResponsePayload>> GetVideoEncoderConfigurationOptionsInt(GetVideoEncoderConfigurationOptionsRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetVideoEncoderConfigurationOptionsResponseSchema> extended = await this.getVideoEncoderConfigurationOptionsCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetVideoEncoderConfigurationOptionsResponsePayload>
                    {
                        Response = new GetVideoEncoderConfigurationOptionsResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetGuaranteedNumberOfVideoEncoderInstancesResponsePayload>> GetGuaranteedNumberOfVideoEncoderInstancesInt(GetGuaranteedNumberOfVideoEncoderInstancesRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetGuaranteedNumberOfVideoEncoderInstancesResponseSchema> extended = await this.getGuaranteedNumberOfVideoEncoderInstancesCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetGuaranteedNumberOfVideoEncoderInstancesResponsePayload>
                    {
                        Response = new GetGuaranteedNumberOfVideoEncoderInstancesResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetVideoSourcesResponsePayload>> GetVideoSourcesInt(EmptyJson request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetVideoSourcesResponseSchema> extended = await this.getVideoSourcesCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetVideoSourcesResponsePayload>
                    {
                        Response = new GetVideoSourcesResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetVideoSourceConfigurationResponsePayload>> GetVideoSourceConfigurationInt(GetVideoSourceConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetVideoSourceConfigurationResponseSchema> extended = await this.getVideoSourceConfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetVideoSourceConfigurationResponsePayload>
                    {
                        Response = new GetVideoSourceConfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetVideoSourceConfigurationsResponsePayload>> GetVideoSourceConfigurationsInt(EmptyJson request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetVideoSourceConfigurationsResponseSchema> extended = await this.getVideoSourceConfigurationsCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetVideoSourceConfigurationsResponsePayload>
                    {
                        Response = new GetVideoSourceConfigurationsResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<AddVideoSourceConfigurationResponsePayload>> AddVideoSourceConfigurationInt(AddVideoSourceConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<AddVideoSourceConfigurationResponseSchema> extended = await this.addVideoSourceConfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<AddVideoSourceConfigurationResponsePayload>
                    {
                        Response = new AddVideoSourceConfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<RemoveVideoSourceConfigurationResponsePayload>> RemoveVideoSourceConfigurationInt(RemoveVideoSourceConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<RemoveVideoSourceConfigurationResponseSchema> extended = await this.removeVideoSourceConfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<RemoveVideoSourceConfigurationResponsePayload>
                    {
                        Response = new RemoveVideoSourceConfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<SetVideoSourceConfigurationResponsePayload>> SetVideoSourceConfigurationInt(SetVideoSourceConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<SetVideoSourceConfigurationResponseSchema> extended = await this.setVideoSourceConfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<SetVideoSourceConfigurationResponsePayload>
                    {
                        Response = new SetVideoSourceConfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetCompatibleVideoSourceConfigurationsResponsePayload>> GetCompatibleVideoSourceConfigurationsInt(GetCompatibleVideoSourceConfigurationsRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetCompatibleVideoSourceConfigurationsResponseSchema> extended = await this.getCompatibleVideoSourceConfigurationsCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetCompatibleVideoSourceConfigurationsResponsePayload>
                    {
                        Response = new GetCompatibleVideoSourceConfigurationsResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetVideoSourceConfigurationOptionsResponsePayload>> GetVideoSourceConfigurationOptionsInt(GetVideoSourceConfigurationOptionsRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetVideoSourceConfigurationOptionsResponseSchema> extended = await this.getVideoSourceConfigurationOptionsCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetVideoSourceConfigurationOptionsResponsePayload>
                    {
                        Response = new GetVideoSourceConfigurationOptionsResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetMetadataConfigurationResponsePayload>> GetMetadataConfigurationInt(GetMetadataConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetMetadataConfigurationResponseSchema> extended = await this.getMetadataConfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetMetadataConfigurationResponsePayload>
                    {
                        Response = new GetMetadataConfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetMetadataConfigurationsResponsePayload>> GetMetadataConfigurationsInt(EmptyJson request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetMetadataConfigurationsResponseSchema> extended = await this.getMetadataConfigurationsCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetMetadataConfigurationsResponsePayload>
                    {
                        Response = new GetMetadataConfigurationsResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetCompatibleMetadataConfigurationsResponsePayload>> GetCompatibleMetadataConfigurationsInt(GetCompatibleMetadataConfigurationsRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetCompatibleMetadataConfigurationsResponseSchema> extended = await this.getCompatibleMetadataConfigurationsCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetCompatibleMetadataConfigurationsResponsePayload>
                    {
                        Response = new GetCompatibleMetadataConfigurationsResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<AddMetadataConfigurationResponsePayload>> AddMetadataConfigurationInt(AddMetadataConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<AddMetadataConfigurationResponseSchema> extended = await this.addMetadataConfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<AddMetadataConfigurationResponsePayload>
                    {
                        Response = new AddMetadataConfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<SetMetadataConfigurationResponsePayload>> SetMetadataConfigurationInt(SetMetadataConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<SetMetadataConfigurationResponseSchema> extended = await this.setMetadataConfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<SetMetadataConfigurationResponsePayload>
                    {
                        Response = new SetMetadataConfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<RemoveMetadataConfigurationResponsePayload>> RemoveMetadataConfigurationInt(RemoveMetadataConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<RemoveMetadataConfigurationResponseSchema> extended = await this.removeMetadataConfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<RemoveMetadataConfigurationResponsePayload>
                    {
                        Response = new RemoveMetadataConfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetMetadataConfigurationOptionsResponsePayload>> GetMetadataConfigurationOptionsInt(GetMetadataConfigurationOptionsRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetMetadataConfigurationOptionsResponseSchema> extended = await this.getMetadataConfigurationOptionsCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetMetadataConfigurationOptionsResponsePayload>
                    {
                        Response = new GetMetadataConfigurationOptionsResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<SetSynchronizationPointResponsePayload>> SetSynchronizationPointInt(SetSynchronizationPointRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<SetSynchronizationPointResponseSchema> extended = await this.setSynchronizationPointCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<SetSynchronizationPointResponsePayload>
                    {
                        Response = new SetSynchronizationPointResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<AddPtzconfigurationResponsePayload>> AddPtzconfigurationInt(AddPtzconfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<AddPtzconfigurationResponseSchema> extended = await this.addPtzconfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<AddPtzconfigurationResponsePayload>
                    {
                        Response = new AddPtzconfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<RemovePtzconfigurationResponsePayload>> RemovePtzconfigurationInt(RemovePtzconfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<RemovePtzconfigurationResponseSchema> extended = await this.removePtzconfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<RemovePtzconfigurationResponsePayload>
                    {
                        Response = new RemovePtzconfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetAudioSourcesResponsePayload>> GetAudioSourcesInt(EmptyJson request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetAudioSourcesResponseSchema> extended = await this.getAudioSourcesCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetAudioSourcesResponsePayload>
                    {
                        Response = new GetAudioSourcesResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetAudioSourceConfigurationResponsePayload>> GetAudioSourceConfigurationInt(GetAudioSourceConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetAudioSourceConfigurationResponseSchema> extended = await this.getAudioSourceConfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetAudioSourceConfigurationResponsePayload>
                    {
                        Response = new GetAudioSourceConfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetAudioSourceConfigurationsResponsePayload>> GetAudioSourceConfigurationsInt(EmptyJson request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetAudioSourceConfigurationsResponseSchema> extended = await this.getAudioSourceConfigurationsCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetAudioSourceConfigurationsResponsePayload>
                    {
                        Response = new GetAudioSourceConfigurationsResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<AddAudioSourceConfigurationResponsePayload>> AddAudioSourceConfigurationInt(AddAudioSourceConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<AddAudioSourceConfigurationResponseSchema> extended = await this.addAudioSourceConfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<AddAudioSourceConfigurationResponsePayload>
                    {
                        Response = new AddAudioSourceConfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<RemoveAudioSourceConfigurationResponsePayload>> RemoveAudioSourceConfigurationInt(RemoveAudioSourceConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<RemoveAudioSourceConfigurationResponseSchema> extended = await this.removeAudioSourceConfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<RemoveAudioSourceConfigurationResponsePayload>
                    {
                        Response = new RemoveAudioSourceConfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<SetAudioSourceConfigurationResponsePayload>> SetAudioSourceConfigurationInt(SetAudioSourceConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<SetAudioSourceConfigurationResponseSchema> extended = await this.setAudioSourceConfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<SetAudioSourceConfigurationResponsePayload>
                    {
                        Response = new SetAudioSourceConfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetAudioSourceConfigurationOptionsResponsePayload>> GetAudioSourceConfigurationOptionsInt(GetAudioSourceConfigurationOptionsRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetAudioSourceConfigurationOptionsResponseSchema> extended = await this.getAudioSourceConfigurationOptionsCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetAudioSourceConfigurationOptionsResponsePayload>
                    {
                        Response = new GetAudioSourceConfigurationOptionsResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetCompatibleAudioSourceConfigurationsResponsePayload>> GetCompatibleAudioSourceConfigurationsInt(GetCompatibleAudioSourceConfigurationsRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetCompatibleAudioSourceConfigurationsResponseSchema> extended = await this.getCompatibleAudioSourceConfigurationsCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetCompatibleAudioSourceConfigurationsResponsePayload>
                    {
                        Response = new GetCompatibleAudioSourceConfigurationsResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetAudioEncoderConfigurationResponsePayload>> GetAudioEncoderConfigurationInt(GetAudioEncoderConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetAudioEncoderConfigurationResponseSchema> extended = await this.getAudioEncoderConfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetAudioEncoderConfigurationResponsePayload>
                    {
                        Response = new GetAudioEncoderConfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetAudioEncoderConfigurationsResponsePayload>> GetAudioEncoderConfigurationsInt(EmptyJson request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetAudioEncoderConfigurationsResponseSchema> extended = await this.getAudioEncoderConfigurationsCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetAudioEncoderConfigurationsResponsePayload>
                    {
                        Response = new GetAudioEncoderConfigurationsResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<AddAudioEncoderConfigurationResponsePayload>> AddAudioEncoderConfigurationInt(AddAudioEncoderConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<AddAudioEncoderConfigurationResponseSchema> extended = await this.addAudioEncoderConfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<AddAudioEncoderConfigurationResponsePayload>
                    {
                        Response = new AddAudioEncoderConfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<RemoveAudioEncoderConfigurationResponsePayload>> RemoveAudioEncoderConfigurationInt(RemoveAudioEncoderConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<RemoveAudioEncoderConfigurationResponseSchema> extended = await this.removeAudioEncoderConfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<RemoveAudioEncoderConfigurationResponsePayload>
                    {
                        Response = new RemoveAudioEncoderConfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<SetAudioEncoderConfigurationResponsePayload>> SetAudioEncoderConfigurationInt(SetAudioEncoderConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<SetAudioEncoderConfigurationResponseSchema> extended = await this.setAudioEncoderConfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<SetAudioEncoderConfigurationResponsePayload>
                    {
                        Response = new SetAudioEncoderConfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetCompatibleAudioEncoderConfigurationsResponsePayload>> GetCompatibleAudioEncoderConfigurationsInt(GetCompatibleAudioEncoderConfigurationsRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetCompatibleAudioEncoderConfigurationsResponseSchema> extended = await this.getCompatibleAudioEncoderConfigurationsCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetCompatibleAudioEncoderConfigurationsResponsePayload>
                    {
                        Response = new GetCompatibleAudioEncoderConfigurationsResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetAudioEncoderConfigurationOptionsResponsePayload>> GetAudioEncoderConfigurationOptionsInt(GetAudioEncoderConfigurationOptionsRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetAudioEncoderConfigurationOptionsResponseSchema> extended = await this.getAudioEncoderConfigurationOptionsCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetAudioEncoderConfigurationOptionsResponsePayload>
                    {
                        Response = new GetAudioEncoderConfigurationOptionsResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<StartMulticastStreamingResponsePayload>> StartMulticastStreamingInt(StartMulticastStreamingRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<StartMulticastStreamingResponseSchema> extended = await this.startMulticastStreamingCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<StartMulticastStreamingResponsePayload>
                    {
                        Response = new StartMulticastStreamingResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            public async ValueTask DisposeAsync()
            {
                await this.getProfileCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getProfilesCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.createProfileCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.deleteProfileCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getVideoEncoderConfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getVideoEncoderConfigurationsCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.addVideoEncoderConfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.removeVideoEncoderConfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.setVideoEncoderConfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getCompatibleVideoEncoderConfigurationsCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getVideoEncoderConfigurationOptionsCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getGuaranteedNumberOfVideoEncoderInstancesCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getVideoSourcesCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getVideoSourceConfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getVideoSourceConfigurationsCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.addVideoSourceConfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.removeVideoSourceConfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.setVideoSourceConfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getCompatibleVideoSourceConfigurationsCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getVideoSourceConfigurationOptionsCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getMetadataConfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getMetadataConfigurationsCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getCompatibleMetadataConfigurationsCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.addMetadataConfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.setMetadataConfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.removeMetadataConfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getMetadataConfigurationOptionsCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.setSynchronizationPointCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.addPtzconfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.removePtzconfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getAudioSourcesCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getAudioSourceConfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getAudioSourceConfigurationsCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.addAudioSourceConfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.removeAudioSourceConfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.setAudioSourceConfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getAudioSourceConfigurationOptionsCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getCompatibleAudioSourceConfigurationsCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getAudioEncoderConfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getAudioEncoderConfigurationsCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.addAudioEncoderConfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.removeAudioEncoderConfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.setAudioEncoderConfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getCompatibleAudioEncoderConfigurationsCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getAudioEncoderConfigurationOptionsCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.startMulticastStreamingCommandInvoker.DisposeAsync().ConfigureAwait(false);
            }

            public async ValueTask DisposeAsync(bool disposing)
            {
                await this.getProfileCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getProfilesCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.createProfileCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.deleteProfileCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getVideoEncoderConfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getVideoEncoderConfigurationsCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.addVideoEncoderConfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.removeVideoEncoderConfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.setVideoEncoderConfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getCompatibleVideoEncoderConfigurationsCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getVideoEncoderConfigurationOptionsCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getGuaranteedNumberOfVideoEncoderInstancesCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getVideoSourcesCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getVideoSourceConfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getVideoSourceConfigurationsCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.addVideoSourceConfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.removeVideoSourceConfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.setVideoSourceConfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getCompatibleVideoSourceConfigurationsCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getVideoSourceConfigurationOptionsCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getMetadataConfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getMetadataConfigurationsCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getCompatibleMetadataConfigurationsCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.addMetadataConfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.setMetadataConfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.removeMetadataConfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getMetadataConfigurationOptionsCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.setSynchronizationPointCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.addPtzconfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.removePtzconfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getAudioSourcesCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getAudioSourceConfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getAudioSourceConfigurationsCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.addAudioSourceConfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.removeAudioSourceConfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.setAudioSourceConfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getAudioSourceConfigurationOptionsCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getCompatibleAudioSourceConfigurationsCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getAudioEncoderConfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getAudioEncoderConfigurationsCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.addAudioEncoderConfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.removeAudioEncoderConfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.setAudioEncoderConfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getCompatibleAudioEncoderConfigurationsCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getAudioEncoderConfigurationOptionsCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.startMulticastStreamingCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
            }
        }
    }
}
