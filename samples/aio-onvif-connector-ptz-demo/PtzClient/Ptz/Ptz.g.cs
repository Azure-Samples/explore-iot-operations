/* Code generated by Azure.Iot.Operations.ProtocolCompiler v0.10.0.0; DO NOT EDIT. */

#nullable enable

namespace PtzClient.Ptz
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading;
    using System.Threading.Tasks;
    using Azure.Iot.Operations.Protocol.Models;
    using Azure.Iot.Operations.Protocol;
    using Azure.Iot.Operations.Protocol.RPC;
    using Azure.Iot.Operations.Protocol.Telemetry;
    using PtzClient;

    [CommandTopic("{ex:namespace}/mrpc/{ex:asset}/{commandName}")]
    [System.CodeDom.Compiler.GeneratedCode("Azure.Iot.Operations.ProtocolCompiler", "0.10.0.0")]
    public static partial class Ptz
    {
        public abstract partial class Client : IAsyncDisposable
        {
            private ApplicationContext applicationContext;
            private IMqttPubSubClient mqttClient;
            private readonly AbsoluteMoveCommandInvoker absoluteMoveCommandInvoker;
            private readonly ContinuousMoveCommandInvoker continuousMoveCommandInvoker;
            private readonly GetConfigurationOptionsCommandInvoker getConfigurationOptionsCommandInvoker;
            private readonly GetConfigurationCommandInvoker getConfigurationCommandInvoker;
            private readonly GetConfigurationsCommandInvoker getConfigurationsCommandInvoker;
            private readonly GetNodeCommandInvoker getNodeCommandInvoker;
            private readonly GetNodesCommandInvoker getNodesCommandInvoker;
            private readonly GetPresetsCommandInvoker getPresetsCommandInvoker;
            private readonly GetStatusCommandInvoker getStatusCommandInvoker;
            private readonly GotoHomePositionCommandInvoker gotoHomePositionCommandInvoker;
            private readonly GotoPresetCommandInvoker gotoPresetCommandInvoker;
            private readonly RelativeMoveCommandInvoker relativeMoveCommandInvoker;
            private readonly RemovePresetCommandInvoker removePresetCommandInvoker;
            private readonly SendAuxiliaryCommandCommandInvoker sendAuxiliaryCommandCommandInvoker;
            private readonly SetConfigurationCommandInvoker setConfigurationCommandInvoker;
            private readonly SetHomePositionCommandInvoker setHomePositionCommandInvoker;
            private readonly SetPresetCommandInvoker setPresetCommandInvoker;
            private readonly StopCommandInvoker stopCommandInvoker;

            /// <summary>
            /// Construct a new instance of this client.
            /// </summary>
            /// <param name="applicationContext">The shared context for your application.</param>
            /// <param name="mqttClient">The MQTT client to use.</param>
            /// <param name="topicTokenMap">
            /// The topic token replacement map to use for all operations by default. Generally, this will include the token values
            /// for topic tokens such as "modelId" which should be the same for the duration of this client's lifetime. Note that
            /// additional topic tokens can be specified when starting the client with <see cref="StartAsync(Dictionary{string, string}?, int?, CancellationToken)"/>.
            /// </param>
            public Client(ApplicationContext applicationContext, IMqttPubSubClient mqttClient, Dictionary<string, string>? topicTokenMap = null)
            {
                this.applicationContext = applicationContext;
                this.mqttClient = mqttClient;

                this.absoluteMoveCommandInvoker = new AbsoluteMoveCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.absoluteMoveCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.continuousMoveCommandInvoker = new ContinuousMoveCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.continuousMoveCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getConfigurationOptionsCommandInvoker = new GetConfigurationOptionsCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getConfigurationOptionsCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getConfigurationCommandInvoker = new GetConfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getConfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getConfigurationsCommandInvoker = new GetConfigurationsCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getConfigurationsCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getNodeCommandInvoker = new GetNodeCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getNodeCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getNodesCommandInvoker = new GetNodesCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getNodesCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getPresetsCommandInvoker = new GetPresetsCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getPresetsCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.getStatusCommandInvoker = new GetStatusCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.getStatusCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.gotoHomePositionCommandInvoker = new GotoHomePositionCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.gotoHomePositionCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.gotoPresetCommandInvoker = new GotoPresetCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.gotoPresetCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.relativeMoveCommandInvoker = new RelativeMoveCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.relativeMoveCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.removePresetCommandInvoker = new RemovePresetCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.removePresetCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.sendAuxiliaryCommandCommandInvoker = new SendAuxiliaryCommandCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.sendAuxiliaryCommandCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.setConfigurationCommandInvoker = new SetConfigurationCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.setConfigurationCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.setHomePositionCommandInvoker = new SetHomePositionCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.setHomePositionCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.setPresetCommandInvoker = new SetPresetCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.setPresetCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
                this.stopCommandInvoker = new StopCommandInvoker(applicationContext, mqttClient);
                if (topicTokenMap != null)
                {
                    foreach (string topicTokenKey in topicTokenMap.Keys)
                    {
                        this.stopCommandInvoker.TopicTokenMap.TryAdd("ex:" + topicTokenKey, topicTokenMap[topicTokenKey]);
                    }
                }
            }

            public AbsoluteMoveCommandInvoker AbsoluteMoveCommandInvoker { get => this.absoluteMoveCommandInvoker; }

            public ContinuousMoveCommandInvoker ContinuousMoveCommandInvoker { get => this.continuousMoveCommandInvoker; }

            public GetConfigurationOptionsCommandInvoker GetConfigurationOptionsCommandInvoker { get => this.getConfigurationOptionsCommandInvoker; }

            public GetConfigurationCommandInvoker GetConfigurationCommandInvoker { get => this.getConfigurationCommandInvoker; }

            public GetConfigurationsCommandInvoker GetConfigurationsCommandInvoker { get => this.getConfigurationsCommandInvoker; }

            public GetNodeCommandInvoker GetNodeCommandInvoker { get => this.getNodeCommandInvoker; }

            public GetNodesCommandInvoker GetNodesCommandInvoker { get => this.getNodesCommandInvoker; }

            public GetPresetsCommandInvoker GetPresetsCommandInvoker { get => this.getPresetsCommandInvoker; }

            public GetStatusCommandInvoker GetStatusCommandInvoker { get => this.getStatusCommandInvoker; }

            public GotoHomePositionCommandInvoker GotoHomePositionCommandInvoker { get => this.gotoHomePositionCommandInvoker; }

            public GotoPresetCommandInvoker GotoPresetCommandInvoker { get => this.gotoPresetCommandInvoker; }

            public RelativeMoveCommandInvoker RelativeMoveCommandInvoker { get => this.relativeMoveCommandInvoker; }

            public RemovePresetCommandInvoker RemovePresetCommandInvoker { get => this.removePresetCommandInvoker; }

            public SendAuxiliaryCommandCommandInvoker SendAuxiliaryCommandCommandInvoker { get => this.sendAuxiliaryCommandCommandInvoker; }

            public SetConfigurationCommandInvoker SetConfigurationCommandInvoker { get => this.setConfigurationCommandInvoker; }

            public SetHomePositionCommandInvoker SetHomePositionCommandInvoker { get => this.setHomePositionCommandInvoker; }

            public SetPresetCommandInvoker SetPresetCommandInvoker { get => this.setPresetCommandInvoker; }

            public StopCommandInvoker StopCommandInvoker { get => this.stopCommandInvoker; }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<AbsoluteMoveResponsePayload> AbsoluteMoveAsync(AbsoluteMoveRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<AbsoluteMoveResponsePayload>(this.AbsoluteMoveInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<ContinuousMoveResponsePayload> ContinuousMoveAsync(ContinuousMoveRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<ContinuousMoveResponsePayload>(this.ContinuousMoveInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetConfigurationOptionsResponsePayload> GetConfigurationOptionsAsync(GetConfigurationOptionsRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetConfigurationOptionsResponsePayload>(this.GetConfigurationOptionsInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetConfigurationResponsePayload> GetConfigurationAsync(GetConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetConfigurationResponsePayload>(this.GetConfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetConfigurationsResponsePayload> GetConfigurationsAsync(CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetConfigurationsResponsePayload>(this.GetConfigurationsInt(new EmptyJson(), metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetNodeResponsePayload> GetNodeAsync(GetNodeRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetNodeResponsePayload>(this.GetNodeInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetNodesResponsePayload> GetNodesAsync(CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetNodesResponsePayload>(this.GetNodesInt(new EmptyJson(), metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetPresetsResponsePayload> GetPresetsAsync(GetPresetsRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetPresetsResponsePayload>(this.GetPresetsInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GetStatusResponsePayload> GetStatusAsync(GetStatusRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GetStatusResponsePayload>(this.GetStatusInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GotoHomePositionResponsePayload> GotoHomePositionAsync(GotoHomePositionRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GotoHomePositionResponsePayload>(this.GotoHomePositionInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<GotoPresetResponsePayload> GotoPresetAsync(GotoPresetRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<GotoPresetResponsePayload>(this.GotoPresetInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<RelativeMoveResponsePayload> RelativeMoveAsync(RelativeMoveRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<RelativeMoveResponsePayload>(this.RelativeMoveInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<RemovePresetResponsePayload> RemovePresetAsync(RemovePresetRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<RemovePresetResponsePayload>(this.RemovePresetInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<SendAuxiliaryCommandResponsePayload> SendAuxiliaryCommandAsync(SendAuxiliaryCommandRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<SendAuxiliaryCommandResponsePayload>(this.SendAuxiliaryCommandInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<SetConfigurationResponsePayload> SetConfigurationAsync(SetConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<SetConfigurationResponsePayload>(this.SetConfigurationInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<SetHomePositionResponsePayload> SetHomePositionAsync(SetHomePositionRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<SetHomePositionResponsePayload>(this.SetHomePositionInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<SetPresetResponsePayload> SetPresetAsync(SetPresetRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<SetPresetResponsePayload>(this.SetPresetInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            /// <summary>
            /// Invoke a command.
            /// </summary>
            /// <param name="requestMetadata">The metadata for this command request.</param>
            /// <param name="additionalTopicTokenMap">
            /// The topic token replacement map to use in addition to the topic tokens specified in the constructor. If this map
            /// contains any keys that the topic tokens specified in the constructor also has, then values specified in this map will take precedence.
            /// </param>
            /// <param name="commandTimeout">How long the command will be available on the broker for an executor to receive.</param>
            /// <param name="cancellationToken">Cancellation token.</param>
            /// <returns>The command response.</returns>
            public RpcCallAsync<StopResponsePayload> StopAsync(StopRequestPayload request, CommandRequestMetadata? requestMetadata = null, Dictionary<string, string>? additionalTopicTokenMap = null, TimeSpan? commandTimeout = default, CancellationToken cancellationToken = default)
            {
                string? clientId = this.mqttClient.ClientId;
                if (string.IsNullOrEmpty(clientId))
                {
                    throw new InvalidOperationException("No MQTT client Id configured. Must connect to MQTT broker before invoking command.");
                }

                CommandRequestMetadata metadata = requestMetadata ?? new CommandRequestMetadata();
                additionalTopicTokenMap ??= new();

                Dictionary<string, string> prefixedAdditionalTopicTokenMap = new();
                foreach (string key in additionalTopicTokenMap.Keys)
                {
                    prefixedAdditionalTopicTokenMap["ex:" + key] = additionalTopicTokenMap[key];
                }

                prefixedAdditionalTopicTokenMap["invokerClientId"] = clientId;

                return new RpcCallAsync<StopResponsePayload>(this.StopInt(request, metadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken), metadata.CorrelationId);
            }

            private async Task<ExtendedResponse<AbsoluteMoveResponsePayload>> AbsoluteMoveInt(AbsoluteMoveRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<AbsoluteMoveResponseSchema> extended = await this.absoluteMoveCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<AbsoluteMoveResponsePayload>
                    {
                        Response = new AbsoluteMoveResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<ContinuousMoveResponsePayload>> ContinuousMoveInt(ContinuousMoveRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<ContinuousMoveResponseSchema> extended = await this.continuousMoveCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<ContinuousMoveResponsePayload>
                    {
                        Response = new ContinuousMoveResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetConfigurationOptionsResponsePayload>> GetConfigurationOptionsInt(GetConfigurationOptionsRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetConfigurationOptionsResponseSchema> extended = await this.getConfigurationOptionsCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetConfigurationOptionsResponsePayload>
                    {
                        Response = new GetConfigurationOptionsResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetConfigurationResponsePayload>> GetConfigurationInt(GetConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetConfigurationResponseSchema> extended = await this.getConfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetConfigurationResponsePayload>
                    {
                        Response = new GetConfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetConfigurationsResponsePayload>> GetConfigurationsInt(EmptyJson request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetConfigurationsResponseSchema> extended = await this.getConfigurationsCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetConfigurationsResponsePayload>
                    {
                        Response = new GetConfigurationsResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetNodeResponsePayload>> GetNodeInt(GetNodeRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetNodeResponseSchema> extended = await this.getNodeCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetNodeResponsePayload>
                    {
                        Response = new GetNodeResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetNodesResponsePayload>> GetNodesInt(EmptyJson request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetNodesResponseSchema> extended = await this.getNodesCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetNodesResponsePayload>
                    {
                        Response = new GetNodesResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetPresetsResponsePayload>> GetPresetsInt(GetPresetsRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetPresetsResponseSchema> extended = await this.getPresetsCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetPresetsResponsePayload>
                    {
                        Response = new GetPresetsResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GetStatusResponsePayload>> GetStatusInt(GetStatusRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GetStatusResponseSchema> extended = await this.getStatusCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GetStatusResponsePayload>
                    {
                        Response = new GetStatusResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GotoHomePositionResponsePayload>> GotoHomePositionInt(GotoHomePositionRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GotoHomePositionResponseSchema> extended = await this.gotoHomePositionCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GotoHomePositionResponsePayload>
                    {
                        Response = new GotoHomePositionResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<GotoPresetResponsePayload>> GotoPresetInt(GotoPresetRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<GotoPresetResponseSchema> extended = await this.gotoPresetCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<GotoPresetResponsePayload>
                    {
                        Response = new GotoPresetResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<RelativeMoveResponsePayload>> RelativeMoveInt(RelativeMoveRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<RelativeMoveResponseSchema> extended = await this.relativeMoveCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<RelativeMoveResponsePayload>
                    {
                        Response = new RelativeMoveResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<RemovePresetResponsePayload>> RemovePresetInt(RemovePresetRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<RemovePresetResponseSchema> extended = await this.removePresetCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<RemovePresetResponsePayload>
                    {
                        Response = new RemovePresetResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<SendAuxiliaryCommandResponsePayload>> SendAuxiliaryCommandInt(SendAuxiliaryCommandRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<SendAuxiliaryCommandResponseSchema> extended = await this.sendAuxiliaryCommandCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<SendAuxiliaryCommandResponsePayload>
                    {
                        Response = new SendAuxiliaryCommandResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<SetConfigurationResponsePayload>> SetConfigurationInt(SetConfigurationRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<SetConfigurationResponseSchema> extended = await this.setConfigurationCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<SetConfigurationResponsePayload>
                    {
                        Response = new SetConfigurationResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<SetHomePositionResponsePayload>> SetHomePositionInt(SetHomePositionRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<SetHomePositionResponseSchema> extended = await this.setHomePositionCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<SetHomePositionResponsePayload>
                    {
                        Response = new SetHomePositionResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<SetPresetResponsePayload>> SetPresetInt(SetPresetRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<SetPresetResponseSchema> extended = await this.setPresetCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<SetPresetResponsePayload>
                    {
                        Response = new SetPresetResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            private async Task<ExtendedResponse<StopResponsePayload>> StopInt(StopRequestPayload request, CommandRequestMetadata? requestMetadata, Dictionary<string, string>? prefixedAdditionalTopicTokenMap, TimeSpan? commandTimeout, CancellationToken cancellationToken)
            {
                ExtendedResponse<StopResponseSchema> extended = await this.stopCommandInvoker.InvokeCommandAsync(request, requestMetadata, prefixedAdditionalTopicTokenMap, commandTimeout, cancellationToken);
                if (extended.Response.Error != null)
                {
                    throw new OnvifErrorException(extended.Response.Error);
                }
                else if (extended.Response.Result == null)
                {
                    throw new AkriMqttException("Command response has neither normal nor error payload content")
                    {
                        Kind = AkriMqttErrorKind.PayloadInvalid,
                        IsShallow = false,
                        IsRemote = false,
                    };
                }
                else
                {
                    return new ExtendedResponse<StopResponsePayload>
                    {
                        Response = new StopResponsePayload { Result = extended.Response.Result.Value() },
                        ResponseMetadata = extended.ResponseMetadata,
                    };
                }
            }

            public async ValueTask DisposeAsync()
            {
                await this.absoluteMoveCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.continuousMoveCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getConfigurationOptionsCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getConfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getConfigurationsCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getNodeCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getNodesCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getPresetsCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.getStatusCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.gotoHomePositionCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.gotoPresetCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.relativeMoveCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.removePresetCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.sendAuxiliaryCommandCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.setConfigurationCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.setHomePositionCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.setPresetCommandInvoker.DisposeAsync().ConfigureAwait(false);
                await this.stopCommandInvoker.DisposeAsync().ConfigureAwait(false);
            }

            public async ValueTask DisposeAsync(bool disposing)
            {
                await this.absoluteMoveCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.continuousMoveCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getConfigurationOptionsCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getConfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getConfigurationsCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getNodeCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getNodesCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getPresetsCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.getStatusCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.gotoHomePositionCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.gotoPresetCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.relativeMoveCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.removePresetCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.sendAuxiliaryCommandCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.setConfigurationCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.setHomePositionCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.setPresetCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
                await this.stopCommandInvoker.DisposeAsync(disposing).ConfigureAwait(false);
            }
        }
    }
}
